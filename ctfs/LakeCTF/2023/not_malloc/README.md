CTFtime: https://ctftime.org/task/26966

In this challenge we have a `malloc` implementation with seperate memory for data and metadata.
Because the mapped memory for data heap is right before metadata heap, and we are using `MAP_FIXED` flag
to extend the heap mappings in `extend_mapping()` (in case top chunk doesn't have enough memory), the data and metadata heaps will overlap if we request a large chunk and it will allow us to overwrite metadata. This way, we will allocate a chunk whose data lies in the metadata region and by using the `show` command on this chunk we leak heap addresses. Because the heap is at a constant offset from `libnotmalloc.so` pages, we also have the `libnotmalloc.so` addresses now. (The offset from `data_heap` to the base of `libnotmalloc.so` was different between local and remote/docker versions so we have `exploit.py` which works with remote/docker and `local_exploit.py` which works with local binary on my system (at least now)). We right `printf@plt` from `libnotmalloc.so` plt into `extend_mapping@got` in the `libnotmalloc.so` GOT. This will give us a format string when requesting large chunks, which we can use to leak everything (stack, libc, binary base, etc.). We then use these leaks to write `gets@libc` into `get_free_chunk@plt` to read a ROP payload on to the stack. Due to the seccomp filter (which is described in file `bpf_filter.bpf`) we can't `execve` so we will `open/read/write` the flag onto the screen. This was a nice challenge to exploit a custom memory allocator implementation.
