**Summary**: Writing shellcode to find the flag file and leaking shellcode bit-by-bit through a side-channel

In this challenge, we can have our shellcode (with length at most 123 bytes) executed on the remote service. There is a seccomp sandbox that only allow `openat`, `read`, and `getdents` syscalls. Additionally, the challenge description mentions that the flag is in an arbitrarily-named file in the current directory, but the file name consists only of `[A-Zaz0-9]` and it is the only file that ends with `.txt`.

In the first step, our shellcode (as written in `shellcode.s`) will get the list of files and directories in the current directory using `getdents`. Then, we will find the flag file by having a loop that will look for a file ending in `.txt`. You can see a description of the structures returned by `getdents` in `man getdents`. Then, we can open the flag file and read the flag.

The second step is to leak the flag, as we no longer have access to the `write` syscall. We will do this using a side-channel. Each time we interact with the remote program, we will send a slightly modified shellcode that will check only one bit in the flag and it will either force the program into an infinite loop (if that bit was zero) or let the program segfault and terminate after trying to execute past the end of our shellcode. This was, by checking to see if the remote program hangs infinitely or closes the connection, we can read one bit of the flag. We will use `solve.py` to send a slightly modified version of the shellcode each time, checking for all of the bits of the flag one by one.
